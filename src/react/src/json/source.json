[{"id":1589289846880,"comment":{"title":"Blob对象与文件操纵","date":"2019-12-23 13:01:48","tags":"-JavaScript","categories":"-前端知识"},"summary":["<p>Blob对象代表类文件对象。</p>","<p>File对象继承并实现了Blob对象定义的接口，以支持用户系统的文件。</p>"],"author":"","anchors":[{"id":"Blob-0","level":2,"text":"Blob"},{"id":"构造-0","level":3,"text":"构造"},{"id":"属性-0","level":3,"text":"属性"},{"id":"方法-0","level":3,"text":"方法"},{"id":"File-0","level":2,"text":"File"},{"id":"构造-1","level":3,"text":"构造"},{"id":"属性-1","level":3,"text":"属性"},{"id":"方法-1","level":3,"text":"方法"},{"id":"对象URL-0","level":2,"text":"对象URL"},{"id":"语法-0","level":3,"text":"语法"},{"id":"内存管理-0","level":3,"text":"内存管理"},{"id":"实践-0","level":2,"text":"实践"},{"id":"文件上传-0","level":3,"text":"文件上传"},{"id":"文件下载-0","level":3,"text":"文件下载"}],"content":["<h2 id='Blob-0'>Blob</h2>","<h3 id='构造-0'>构造</h3>","<p>通过<code>Blob()</code>构造函数实例化一个Blob对象，语法如下：</p>","<pre>","<code><span class='hl-keyword'>let</span> blob = <span class='hl-keyword'>new</span> Blob(array[, options]);</code>","</pre>","<p>参数解释如下：</p>","<ul>","<li>","<p>array</p>","<p>数组，由<code>ArrayBuffer</code>、<code>ArrayBufferView</code>、<code>Blob</code>、<code>DOMString</code>对象组成，或者是其它类似对象的混合体。</p>","<p><code>DOMString</code>将会被编码为UTF-8。</p>","</li>","</ul>","<ul>","<li>","<p>options<span style=\"margin-left:5px;border-left:7px solid #696969;background-color:#eeeeee\">可选</span></p>","<p>一个可选的<code>BlobPropertyBag</code>字典，可具有以下两个属性：</p>","<ul>","<li>","<p>type</p>","<p>默认值为<code>\"\"</code>。</p>","<p>指定被放置在Blob中数组内容的MIME类型。</p>","</li>","</ul>","<ul>","<li>","<p>endings</p>","<p>默认值为<code>\"transparent\"</code>。</p>","<p>指定包含行结束符<code>\\n</code>的字符串如何被写入。具有两个可选值：<code>\"transparent\"</code>与<code>\"native\"</code>，前者代表保持<code>Blob</code>中保存的结束符不变，后者代表行结束符将更改为符合宿主操作系统的。</p>","</li>","</ul>","</li>","</ul>","<h3 id='属性-0'>属性</h3>","<ul>","<li>","<p>size</p>","<p>由File对象实现。</p>","<p>返回一个File对象指代文件的大小，单位为字节。</p>","</li>","</ul>","<ul>","<li>","<p>type</p>","<p>返回文件的<a title='MIME类型' href='https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types'>MIME类型</a>。</p>","</li>","</ul>","<h3 id='方法-0'>方法</h3>","<ul>","<li>","<p><code>Blob.slice([start[, end[, contentType]]])</code></p>","<p>该方法用于创建一个包含源Blob指定字节范围内数据的新对象。参数解释如下：</p>","<ul>","<li>","<p>start<span style=\"margin-left:5px;border-left:7px solid #696969;background-color:#eeeeee\">可选</span></p>","<p>默认值为0。</p>","<p>第一个会被拷贝至新Blob对象的字节的起始。如果为负，则使用值为Blob的长度加上该负值。如果大于Blob的长度，将返回一个长度为0并且不包含任何数据的Blob对象。</p>","</li>","</ul>","<ul>","<li>","<p>end<span style=\"margin-left:5px;border-left:7px solid #696969;background-color:#eeeeee\">可选</span></p>","<p>默认值为Blob对象的长度，即<code>size</code>属性。</p>","<p>最后一个被拷贝至新Blob对象的字节的位置。传入负值的情况与start类似。</p>","<blockquote>","<p>同数组的slice一致，左闭右开地进行截取。</p>","</blockquote>","</li>","</ul>","<ul>","<li>","<p>contentType<span style=\"margin-left:5px;border-left:7px solid #696969;background-color:#eeeeee\">可选</span></p>","<p>默认值为空字符串。</p>","<p>给新的Blob对象赋予新的MIME类型。</p>","</li>","</ul>","</li>","</ul>","<p>除此之外的其它方法，包括这个方法，浏览器的支持均有限，因此暂时不表。</p>","<h2 id='File-0'>File</h2>","<p>File对象是特殊类型的Blob对象，并且可以用在任意Blob类型的上下文中。</p>","<h3 id='构造-1'>构造</h3>","<p>使用<code>File()</code>构造函数实例化一个File对象，语法如下：</p>","<pre>","<code><span class='hl-keyword'>let</span> file = <span class='hl-keyword'>new</span> File(bits, name[, options])</code>","</pre>","<p>参数解释如下：</p>","<ul>","<li>","<p>bits</p>","<p>由UTF-8编码的文件内容，<code>ArrayBuffer</code>、<code>ArrayBufferView</code>、<code>Blob</code>或者<code>DOMString</code>对象组合成的数组。</p>","</li>","</ul>","<ul>","<li>","<p>name</p>","<p>文件名称，或者文件路径。</p>","</li>","</ul>","<ul>","<li>","<p>options<span style=\"margin-left:5px;border-left:7px solid #696969;background-color:#eeeeee\">可选</span></p>","<p>描述文件的可选属性，可具有以下两个属性：</p>","<ul>","<li>","<p>type</p>","<p>默认值为<code>\"\"</code>。</p>","<p><code>DOMString</code>类型，表示将要放到File对象中的内容的MIME类型。</p>","</li>","</ul>","<ul>","<li>","<p>lastModified</p>","<p>默认值为<code>Date.now()</code>。</p>","<p>表示文件最后修改时间的Unix时间戳，以毫秒计。</p>","</li>","</ul>","</li>","</ul>","<h3 id='属性-1'>属性</h3>","<p>File对象也继承了Blob对象的一些属性，其属性均是只读的。</p>","<ul>","<li>","<p><code>File.lastModified</code></p>","<p>File对象引用的文件的最后修改时间的Unix时间戳，以毫秒计。</p>","</li>","</ul>","<ul>","<li>","<p><code>File.lastModifiedDate</code></p>","<p>文件的最后修改时间对应的Date对象。</p>","</li>","</ul>","<ul>","<li>","<p><code>File.name</code></p>","<p>文件的名字。</p>","</li>","</ul>","<ul>","<li>","<p><code>File.size</code></p>","<p>文件的大小，以字节计。</p>","</li>","</ul>","<ul>","<li>","<p><code>File.type</code></p>","<p>文件的MIME类型。</p>","</li>","</ul>","<ul>","<li>","<p><code>File.webkitRelativePath</code></p>","<p>返回文件的层级结构。</p>","</li>","</ul>","<h3 id='方法-1'>方法</h3>","<p>File对象从Blob对象那里继承了<code>.slice([start[, end[, contentType]]])</code>方法。</p>","<h2 id='对象URL-0'>对象URL</h2>","<p>使用<code>URL.createObjectURL()</code>会创建一个DOMString类型的对象URL，表示指定的<code>File</code>对象或<code>Blob</code>对象，该URL的生命周期与document绑定。</p>","<p>常见的使用场景为实现图像预览（非Base64方法）、Canvas图像下载、文件下载。</p>","<h3 id='语法-0'>语法</h3>","<pre>","<code><span class='hl-keyword'>let</span> url = URL.createObjectURL(object);</code>","</pre>","<p>参数解释如下：</p>","<ul>","<li>","<p>object</p>","<p>用于创建URL的<code>File</code>对象、<code>Blob</code>对象或者<code>MediaSource</code>对象。</p>","</li>","</ul>","<h3 id='内存管理-0'>内存管理</h3>","<p>每次调用<code>URL.createObjectURL()</code>都会创建一个新的URL对象，虽然会在文档退出时自动释放，但为了获得最佳性能和内存使用情况，应主动使用<code>URL.revokeObjectURL(objectURL)</code>将内存释放掉。</p>","<h2 id='实践-0'>实践</h2>","<p>使用Blob对象与File对象可实现常见的业务需求。</p>","<h3 id='文件上传-0'>文件上传</h3>","<p>亦可使用label来激活默认的文件输入框。</p>","<pre>","<code>&lt;input type=\"file\" multiple style=\"display: <span class='hl-object'>none</span>;\" onchange=\"filesInputFunc(<span class='hl-keyword'>this</span>.files)\"&gt;</code>","<code>&lt;button id=\"filesInput\"&gt;上传文件&lt;/button&gt;</code>","</pre>","<pre>","<code><span class='hl-keyword'>const</span> filesInputFunc = files =&gt; {</code>","<code>    <span class='hl-keyword'>let</span> inputs = [...files].map(v =&gt; {</code>","<code>        <span class='hl-keyword'>return</span> fetch('some.url', {</code>","<code>            method : \"POST\",</code>","<code>            <span class='hl-object'>body</span> : v</code>","<code>        });</code>","<code>    });</code>","<code>    Promise.all(inputs).then(res =&gt; {</code>","<code>        //<span class='hl-keyword'>do</span> something ...</code>","<code>    });</code>","<code>}</code>","<code><span class='hl-object'>document</span>.querySelector('#filesInput').addEventListener('click',()=&gt;{</code>","<code>    <span class='hl-keyword'>let</span> input = <span class='hl-object'>document</span>.querySelector('input[type=\"file\"]');</code>","<code>    input.click();</code>","<code>},<span class='hl-keyword'>false</span>)</code>","</pre>","<h3 id='文件下载-0'>文件下载</h3>","<pre>","<code>&lt;input type=\"text\"&gt;</code>","<code>&lt;button id=\"download\"&gt;下载文本&lt;/button&gt;</code>","</pre>","<pre>","<code><span class='hl-keyword'>const</span> downloadAsTxt = (fileName, txt) =&gt; {</code>","<code>    <span class='hl-keyword'>let</span> file = <span class='hl-keyword'>new</span> File([txt], fileName || '文件', {</code>","<code>        type : 'text/txt,charset=UTF-8'</code>","<code>    });</code>","<code>    <span class='hl-keyword'>let</span> a = <span class='hl-object'>document</span>.createElement('a'),</code>","<code>        url = URL.createObjectURL(file);</code>","<code>    a.download = fileName + '.txt';</code>","<code>    a.href = url;</code>","<code>    a.click();</code>","<code>    URL.revokeObjectURL(url);</code>","<code>}</code>","<code><span class='hl-object'>document</span>.querySelector('#download').addEventListener('click',()=&gt;{</code>","<code>    <span class='hl-keyword'>const</span> text = <span class='hl-object'>document</span>.querySelector('input[type=\"text\"]').value;</code>","<code>    text ? downloadAsTxt('文本文件', text) : <span class='hl-keyword'><span class='hl-object'>null</span></span>;</code>","<code>},<span class='hl-keyword'>false</span>);</code>","</pre>"]},{"id":1589289846897,"comment":{"title":"LeetCode之“两数相加”的链表表示","date":"2019-03-02 22:38:26","tags":"[-JavaScript,-LeetCode]","categories":"-算法"},"summary":["<h2 id='题目-0'>题目</h2>","<p>给出两个<strong>非空</strong>的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 <strong>一位</strong> 数字。</p>","<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>","<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>"],"author":"","anchors":[{"id":"题目-0","level":2,"text":"题目"},{"id":"思路-0","level":2,"text":"思路"},{"id":"实现-0","level":2,"text":"实现"},{"id":"成绩-0","level":2,"text":"成绩"},{"id":"改良-0","level":2,"text":"改良"}],"content":["<p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>","<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>","<blockquote>","<p>Example</p>","</blockquote>","<pre>","<code>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</code>","<code>Output: 7 -&gt; 0 -&gt; 8</code>","<code>Explanation: 342 + 465 = 807.</code>","</pre>","<h2 id='思路-0'>思路</h2>","<p>给出定义：<strong>结果链表</strong>の<code>result</code>、<strong>链表节点</strong>の<code>listNode</code>、<strong>输入链表</strong>の<code>l1</code>与<code>l2</code>。</p>","<p>注意链表的结构性，自然想到将两个链表的对应的每一位数字相加，判断是否有进位，并因此<code>new</code>一个<code>listNode</code>，用于存放每次相加的<strong>个位</strong>运算结果，并链接到<u>结果链表</u>。</p>","<p>那么两两相加到什么时候呢？显然是<u>输入链表</u><strong>一个或双方</strong>的<code>next</code>为<code>null</code>的时候，相加结束后，可不要忘了进位的存在。但是，为了方便进行<code>next</code>的赋值操作，我们应该首先判断是哪一个<u>输入链表</u>走到了尽头。</p>","<p>判断之后，依据进位是否存在，进行如下操作：</p>","<ul>","<li>有进位，则与<strong>未到尽头的链表</strong>的每一位进行相加，同样<code>new</code>一个链表节点，与<u>结果链表</u>进行链接。但是需要注意的是，相加过程中会出现：<strong>有进位，但是链表已走到尽头</strong>这种情况。对于这种情况，在<u>结果链表</u>的最后添加一个值为1的<u>链表节点</u>即可。</li>","<li>无进位，直接进行链表的链接。</li>","</ul>","<h2 id='实现-0'>实现</h2>","<pre>","<code>/**</code>","<code> * Definition <span class='hl-keyword'>for</span> singly-linked list.</code>","<code> * <span class='hl-keyword'>function</span> ListNode(val) {</code>","<code> *     <span class='hl-keyword'>this</span>.val = val;</code>","<code> *     <span class='hl-keyword'>this</span>.next = <span class='hl-keyword'><span class='hl-object'>null</span></span>;</code>","<code> * }</code>","<code> */</code>","<code>/**</code>","<code> * @param {ListNode} l1</code>","<code> * @param {ListNode} l2</code>","<code> * @<span class='hl-keyword'>return</span> {ListNode}</code>","<code> */</code>","<code><span class='hl-keyword'>var</span> addTwoNumbers = <span class='hl-keyword'>function</span>(l1, l2) {</code>","<code>    <span class='hl-keyword'>let</span> carry=0,result=0,list=<span class='hl-keyword'>new</span> ListNode(0);</code>","<code>    <span class='hl-keyword'>let</span> that=list;</code>","<code>    <span class='hl-keyword'>while</span>(l1&&l2){</code>","<code>        result+=(l1.val+l2.val+carry);</code>","<code>        result&lt;10?carry=0:carry=1;</code>","<code>        list.val=(result%10);</code>","<code>        l1.next&&l2.next?(list.next=<span class='hl-keyword'>new</span> ListNode(),list=list.next):list.next=<span class='hl-keyword'><span class='hl-object'>null</span></span>;</code>","<code>        l1=l1.next;</code>","<code>        l2=l2.next;</code>","<code>        result=0;</code>","<code>    }</code>","<code>    <span class='hl-keyword'>if</span>(l1||l2){</code>","<code>        <span class='hl-keyword'>if</span>(l1){</code>","<code>            <span class='hl-keyword'>if</span>(carry){</code>","<code>                <span class='hl-keyword'>while</span>(carry&&l1){</code>","<code>                    result+=(l1.val+carry);</code>","<code>                    result&lt;10?carry=0:carry=1;</code>","<code>                    list.next=<span class='hl-keyword'>new</span> ListNode(result%10);</code>","<code>                    list=list.next;</code>","<code>                    l1=l1.next;</code>","<code>                    result=0;</code>","<code>                }</code>","<code>                <span class='hl-keyword'>if</span>(carry){</code>","<code>                    list.next=<span class='hl-keyword'>new</span> ListNode(1);</code>","<code>                    <span class='hl-keyword'>return</span> that;</code>","<code>                }</code>","<code>            }</code>","<code>        list.next=l1;</code>","<code>        }<span class='hl-keyword'>else</span>{</code>","<code>            <span class='hl-keyword'>if</span>(carry){</code>","<code>                <span class='hl-keyword'>while</span>(carry&&l2){</code>","<code>                    result+=(l2.val+carry);</code>","<code>                    result&lt;10?carry=0:carry=1;</code>","<code>                    list.next=<span class='hl-keyword'>new</span> ListNode(result%10);</code>","<code>                    list=list.next;</code>","<code>                    l2=l2.next;</code>","<code>                    result=0;</code>","<code>                }</code>","<code>                <span class='hl-keyword'>if</span>(carry){</code>","<code>                    list.next=<span class='hl-keyword'>new</span> ListNode(1);</code>","<code>                    <span class='hl-keyword'>return</span> that;</code>","<code>                }</code>","<code>            }</code>","<code>            list.next=l2;</code>","<code>        }</code>","<code>    }<span class='hl-keyword'>else</span>{</code>","<code>        carry?list.next=<span class='hl-keyword'>new</span> ListNode(1):list.next=<span class='hl-keyword'><span class='hl-object'>null</span></span>;</code>","<code>    }</code>","<code>    <span class='hl-keyword'>return</span> that;</code>","<code>};</code>","</pre>","<h2 id='成绩-0'>成绩</h2>","<p>Runtime:  <strong>128 ms</strong></p>","<p>Memory Usage:  <strong>38.4 MB</strong></p>","<p>Status:  <strong>Accepted</strong></p>","<h2 id='改良-0'>改良</h2>","<p>在思想一致的情况下，需要尽可能的减少逻辑判断分支。</p>","<p>可以看到我的代码实在是太丑陋了。</p>","<p>我们完全可以通过引用“指针”来控制返回。</p>","<p>你需要知道的是：</p>","<ol start='1'>","<li>在JavaScript中，原始对象<code>Number</code>通过值传递，而对象<code>Object</code>通过引用传递。</li>","<li>你可以尝试将<code>function</code>看作一个对象工厂，于是，你就拥有了对象，也就拥有了“指针”。</li>","<li>三元表达式<code>a?(b,c):d</code>比<code>if else</code><a title='花费更少的时间' href='http://www.cnblogs.com/GavinYoung/archive/2010/05/19/1739062.html'>花费更少的时间</a>。</li>","</ol>","<pre>","<code>/**</code>","<code> * Definition <span class='hl-keyword'>for</span> singly-linked list.</code>","<code> * <span class='hl-keyword'>function</span> ListNode(val) {</code>","<code> *     <span class='hl-keyword'>this</span>.val = val;</code>","<code> *     <span class='hl-keyword'>this</span>.next = <span class='hl-keyword'><span class='hl-object'>null</span></span>;</code>","<code> * }</code>","<code> */</code>","<code>/**</code>","<code> * @param {ListNode} l1</code>","<code> * @param {ListNode} l2</code>","<code> * @<span class='hl-keyword'>return</span> {ListNode}</code>","<code> */</code>","<code><span class='hl-keyword'>var</span> addTwoNumbers = <span class='hl-keyword'>function</span>(l1, l2) {</code>","<code>    <span class='hl-keyword'>let</span> result=<span class='hl-keyword'>new</span> ListNode(0);</code>","<code>    <span class='hl-keyword'>let</span> p=l1,q=l2,current=result,carry=0;</code>","<code>    <span class='hl-keyword'>while</span>(p!=<span class='hl-keyword'><span class='hl-object'>null</span></span>||q!=null){</code>","<code>        <span class='hl-keyword'>let</span> a=(p==<span class='hl-keyword'><span class='hl-object'>null</span></span>)?0:p.val;</code>","<code>        <span class='hl-keyword'>let</span> b=(q==<span class='hl-keyword'><span class='hl-object'>null</span></span>)?0:q.val;</code>","<code>        <span class='hl-keyword'>let</span> sum=a+b+carry;</code>","<code>        (sum&lt;10)?carry=0:carry=1;</code>","<code>        current.next=<span class='hl-keyword'>new</span> ListNode(sum%10);</code>","<code>        current=current.next;</code>","<code>        (p==<span class='hl-keyword'><span class='hl-object'>null</span></span>)?null:p=p.next;</code>","<code>        (q==<span class='hl-keyword'><span class='hl-object'>null</span></span>)?null:q=q.next;</code>","<code>    }</code>","<code>    carry?current.next=<span class='hl-keyword'>new</span> ListNode(1):<span class='hl-keyword'><span class='hl-object'>null</span></span>;</code>","<code>    <span class='hl-keyword'>return</span> result.next;</code>","<code>};</code>","</pre>","<p>Runtime:  <strong>120 ms</strong></p>","<p>Memory Usage:  <strong>38.3 MB</strong></p>","<p>Status:  <strong>Accepted</strong></p>"]},{"id":1589289846915,"comment":{"title":"在MyEclipse中使用JSON对象的依赖包问题","date":"2018-10-11 20:14:09","categories":"-JavaWeb","tags":"-myEclipse"},"summary":["<p>N2考试大魔王要来了！</p>","<p>每天只感觉自己的时间不够用，又恨随着年龄增长，自己的记忆力越发不如从前。当天背的单词转瞬就忘，难受。</p>"],"author":"","anchors":[{"id":"缘由-0","level":2,"text":"缘由"},{"id":"修理-0","level":2,"text":"修理"},{"id":"自我剖析-0","level":2,"text":"自我剖析"}],"content":["<h2 id='缘由-0'>缘由</h2>","<p>前段国庆假期时间，为了不让自己闲着，便临时起意，拉上另一个被编程耽误的歌手——这里就称他为A君吧，打算做一个小项目练手。</p>","<p>由于本人的脑洞较大，我们的小项目，很快地便从一个图书管理系统发酵起来，甚至一度到了收拾不了的地步。但想象总是美好的，但功能需要一步一步来。</p>","<p>为了实现基于<code>Ajax</code>与<code>JSON</code>的动态模糊搜索功能，我们需要使用<code>JSON</code>对象，但是却出了问题。</p>","<h2 id='修理-0'>修理</h2>","<p>所遇到的问题被定义如下：</p>","<p>详细引入<code>JSON</code>相关的依赖<code>jar</code>包后，仍得到一个错误：<code>java.lang.NoClassDefFoundError: net/sf/ezmorph/Morpher</code>，而实际上<code>ezmorph-1.0.6.jar</code>已经被导入，并可找到<code>Morpher</code>类（虽然它只是一个接口）</p>","<p>我们首先来看下在<code>myEclipse</code>中使用<code>JSON</code>对象所依赖的<code>jar</code>包：</p>","<ul>","<li><a href=\"https://github.com/C1erman/c1erman.github.io/blob/master/files/jar/commons-beanutils-1.7.0.jar?raw=true\">commons-beanutils-1.7.0.jar</a></li>","<li><a href=\"https://github.com/C1erman/c1erman.github.io/blob/master/files/jar/commons-collections-3.2.jar?raw=true\">commons-collections-3.2.jar</a></li>","<li><a href=\"https://github.com/C1erman/c1erman.github.io/blob/master/files/jar/commons-httpclient-3.0.jar?raw=true\">commons-httpclient-3.0.jar</a></li>","<li><a href=\"https://github.com/C1erman/c1erman.github.io/blob/master/files/jar/commons-lang-2.3.jar?raw=true\">commons-lang-2.3.jar</a></li>","<li><a href=\"https://github.com/C1erman/c1erman.github.io/blob/master/files/jar/commons-logging-1.0.4.jar?raw=true\">commons-logging-1.0.4.jar</a></li>","<li><a href=\"https://github.com/C1erman/c1erman.github.io/blob/master/files/jar/ezmorph-1.0.3.jar?raw=true\">ezmorph-1.0.3.jar</a></li>","<li><a href=\"https://github.com/C1erman/c1erman.github.io/blob/master/files/jar/json-lib-2.1-jdk15.jar?raw=true\">json-lib-2.1-jdk15.jar</a></li>","<li><a href=\"https://github.com/C1erman/c1erman.github.io/blob/master/files/jar/morph-1.1.1.jar?raw=true\">morph-1.1.1.jar</a></li>","<li><a href=\"https://github.com/C1erman/c1erman.github.io/blob/master/files/jar/struts2-json-plugin-2.2.1.jar?raw=true\">struts2-json-plugin-2.2.1.jar</a></li>","</ul>","<p>解决方法就是，尽可能的使用myEclispe本身所提供的<code>.jar</code>包，具体做法为：</p>","<p>右键项目=>MyEclipse=>Project Facets=>Manage</p>","<p>勾选并确认<code>myEclipse</code>所提供的、于上述依赖包同名的<code>.jar</code>包，点击<code>Apply</code>确保这些包被导入到你的项目中。</p>","<p><img alt='选择.PNG' title='选择.PNG' src='https://i.loli.net/2020/01/02/b6s7MeVgkBHQq5P.png' ></p>","<p>尤其需要注意的是<code>ezmorph-1.0.x.jar</code>这个包，它在这里：</p>","<p><img alt='注意.PNG' title='注意.PNG' src='https://i.loli.net/2020/01/02/ImJol6eHqTf12zn.png' ></p>","<p>问题便可解决。</p>","<h2 id='自我剖析-0'>自我剖析</h2>","<p>当看到<code>NoClassDefFoundError</code>这个字眼时，许多人立刻会说是没有导入相关的依赖包，现在看来原因却不尽相同。</p>","<p>实际上，当我在浩瀚的博客海中有幸看到<a href=\"https://blog.csdn.net/jamesjxin/article/details/46606307\">这篇文章</a>时，便有些感悟了，希望你也可以先去拜读一下。</p>","<p>本次的<code>BUG</code>，很有可能是因为<code>classPath</code>问题所导致的，在不考虑<code>jar</code>包文件版本的情况下，我们可以这样理解：使用<code>myEclipse</code>自带的<code>ezmorph-1.0.6.jar</code>只不过<strong>与其它使用到这个包的函数们</strong>处在一个<code>classPath</code>下，于是，由于<code>classPath</code>所导致的问题便不见了。</p>","<p>反过来我们可以做一个实验，将<code>myEclipse</code>自带的<code>ezmorph-1.0.6.jar</code>以</p>","<p>Build Path => Add External JARs</p>","<p>方式导入到你的项目中，来看一下导致问题出现的真正原因究竟是什么。</p>"]},{"id":1589289846920,"comment":{"title":"LeetCode之计算矩形面积——“盛最多水的容器”","date":"2019-04-29 14:24:04","tags":"[-JavaScript,-LeetCode]","categories":"-算法"},"summary":["<h2 id='题目-0'>题目</h2>","<p>给定 <i>n</i> 个非负整数 <i>a</i>1，<i>a</i>2，...，<i>a</i>n，每个数代表坐标中的一个点 (<i>i</i>, <i>ai</i>) 。在坐标内画 <i>n</i> 条垂直线，垂直线 <i>i</i> 的两个端点分别为 (<i>i</i>, <i>ai</i>) 和 (<i>i</i>, 0)。找出其中的两条线，使得它们与 <i>x</i> 轴共同构成的容器可以容纳最多的水。</p>","<p><strong>说明：</strong>你不能倾斜容器，且 <i>n</i> 的值至少为 2。</p>"],"author":"","anchors":[{"id":"题目-0","level":2,"text":"题目"},{"id":"思路-0","level":2,"text":"思路"},{"id":"实现-0","level":2,"text":"实现"},{"id":"成绩-0","level":2,"text":"成绩"},{"id":"改良-0","level":2,"text":"改良"}],"content":["<p>Given <i>n</i> non-negative integers <i>a1</i>, <i>a2</i>, ..., <i>an</i> , where each represents a point at coordinate (<i>i</i>, <i>ai</i>). <i>n</i> vertical lines are drawn such that the two endpoints of line <i>i</i> is at (<i>i</i>, <i>ai</i>) and (<i>i</i>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>","<p><strong>Note:</strong> You may not slant the container and <i>n</i> is at least 2.</p>","<blockquote>","<p>Example</p>","</blockquote>","<pre>","<code>Input: [1,8,6,2,5,4,8,3,7]</code>","<code>Output: 49</code>","</pre>","<h2 id='思路-0'>思路</h2>","<p>什么，暴力法？不不不，都9102年了谁还想用暴力法来解题。</p>","<p>这道题的关键是，影响矩形面积的关键因素。</p>","<p>对长和宽来说，<strong>最小的那个值对矩形的面积影响最大</strong>。就像这样：</p>","<p><img alt='影响矩形面积的最大因素' title='影响矩形面积的最大因素' src='https://i.loli.net/2020/01/02/ih6748fHaYlGIKA.png' ></p>","<p>那么，只要我们尽可能的将短的线段换成长的线段，就能保证矩形面积向着最大改变。</p>","<p>可能有人不理解，因为在潜意识中，我们认为矩形的面积是长、宽两因素的作用结果，而我们得到的一般规律是针对一个因素改变下的情况。因此，我们需要做的就是将两因素控制为一因素。</p>","<p>于是，我们就可以这么做：</p>","<p>用两个指针，指向给定数组的开头与末尾，即指向两条线段，计算当前的矩形面积。</p>","<p>当左指针小于右指针时：</p>","<ul>","<li>如果左指针指向的线段长度小于右指针指向的线段长度，那么左指针向右移动一个单位</li>","<li>反之，右指针向左移动一个单位</li>","</ul>","<p>就像这样：</p>","<p><img alt='解题过程' title='解题过程' src='https://i.loli.net/2020/01/02/yiTnZALscoN1GpY.png' ></p>","<p>最开始的时候，我们保证了矩形的宽——也就是左、右指针之间的长度差，有最大值。试想，按照我们之间所寻找到的规律，此时矩形的长——左、右指针指向的线段中的最短那根，是影响矩形面积的关键，因为矩形的宽无法继续增加，因此符合单因素条件。</p>","<p>每次减小宽的一个单位，均换取到了单因素情况下矩形面积的最大影响——使矩形的长发生改变。</p>","<p>显然，我们朝着最大矩形面积这条路上走去。</p>","<h2 id='实现-0'>实现</h2>","<pre>","<code>/**</code>","<code> * @param {number[]} height</code>","<code> * @<span class='hl-keyword'>return</span> {number}</code>","<code> */</code>","<code><span class='hl-keyword'>var</span> maxArea = <span class='hl-keyword'>function</span>(height) {</code>","<code>    <span class='hl-keyword'>let</span> max = 0, l = 0, r = height.length -1;</code>","<code>    <span class='hl-keyword'>while</span>(l&lt;r){</code>","<code>        max = Math.max(max, Math.m<span class='hl-keyword'>in</span>(height[l], height[r])*(r -l));</code>","<code>        height[l] &lt; height[r] ? l++:r--;</code>","<code>    }</code>","<code>    <span class='hl-keyword'>return</span> max;</code>","<code>};</code>","</pre>","<h2 id='成绩-0'>成绩</h2>","<p>Runtime:  <strong>76 ms</strong></p>","<p>Memory Usage: <strong>35.6 MB</strong></p>","<p>Status:  <strong>Accepted</strong></p>","<p>faster than <strong>61.31%</strong> of JavaScript online submissions</p>","<p>less than <strong>39.58%</strong> of JavaScript online submissions</p>","<h2 id='改良-0'>改良</h2>","<p>总感觉循环的最后几次是多余的——矩形长的增量已经无法弥补矩形宽的缺失，但对这个边界值的判断暂时还无法准确的掌握，姑且放到下一轮再看吧。</p>","<p>就跟不甘心。</p>"]},{"id":1589289846946,"comment":{"title":"CSS2.2规范","date":"2019-07-14 21:27:02","tags":"-CSS","categories":"-前端知识"},"summary":["<p>CSS规范的重要性被大大低估了。</p>","<p>本文简单翻译CSS2.2规范中的部分章节，这些章节取决于本人尚未掌握或感兴趣的部分。</p>","<p>注意，请不要忽略CSS3。</p>"],"author":"","anchors":[{"id":"前言：关于CSS规范-0","level":2,"text":"前言：关于CSS规范"},{"id":"章五：选择器-0","level":2,"text":"章五：选择器"},{"id":"内容-0","level":3,"text":"内容"},{"id":" 模式匹配-0","level":3,"text":" 模式匹配"},{"id":"章六：分配属性值、级联和继承-0","level":2,"text":"章六：分配属性值、级联和继承"},{"id":"内容-1","level":3,"text":"内容"},{"id":"计算选择器的优先级-0","level":3,"text":"计算选择器的优先级"},{"id":"章八：盒模型-0","level":2,"text":"章八：盒模型"},{"id":"内容-2","level":3,"text":"内容"},{"id":"盒子尺寸-0","level":3,"text":"盒子尺寸"},{"id":"折叠边距-0","level":3,"text":"折叠边距"},{"id":"解决方法-0","level":4,"text":"解决方法"},{"id":"章九：可视格式化模型-0","level":2,"text":"章九：可视格式化模型"},{"id":"内容-3","level":3,"text":"内容"},{"id":"包含块-0","level":3,"text":"包含块"},{"id":"控制盒子生成-0","level":3,"text":"控制盒子生成"},{"id":"块级元素和块盒-0","level":3,"text":"块级元素和块盒"},{"id":"内联级元素和内联盒-0","level":3,"text":"内联级元素和内联盒"},{"id":"普通流-0","level":3,"text":"普通流"},{"id":"块格式化上下文-0","level":3,"text":"块格式化上下文"},{"id":"内联格式化上下文-0","level":3,"text":"内联格式化上下文"},{"id":"相对定位-0","level":3,"text":"相对定位"},{"id":"浮动-0","level":3,"text":"浮动"},{"id":"定位浮动：`float`属性-0","level":3,"text":"定位浮动：<code>float</code>属性"},{"id":"控制浮动旁的流：`clear`属性-0","level":3,"text":"控制浮动旁的流：<code>clear</code>属性"},{"id":"绝对定位-0","level":3,"text":"绝对定位"},{"id":"固定定位-0","level":3,"text":"固定定位"},{"id":"`display`、`position`与`float`之间的联系-0","level":3,"text":"<code>display</code>、<code>position</code>与<code>float</code>之间的联系"},{"id":"指定堆栈级别：`z-index`属性-0","level":3,"text":"指定堆栈级别：<code>z-index</code>属性"},{"id":"章十：可视格式化上下文细节-0","level":2,"text":"章十：可视格式化上下文细节"},{"id":"内容-4","level":3,"text":"内容"},{"id":"包含块的定义-0","level":3,"text":"包含块的定义"},{"id":"内容宽度：`width`属性-0","level":3,"text":"内容宽度：<code>width</code>属性"},{"id":"计算宽度和边距-0","level":3,"text":"计算宽度和边距"},{"id":"声明-0","level":2,"text":"声明"}],"content":["<h2 id='前言：关于CSS规范-0'>前言：关于CSS规范</h2>","<p>CSS规范是由W3C制定的，用于描述层叠样式表作用方式的文档。</p>","<p>一篇文档的撰写进程如下表所述：</p>","<table>","<thead><tr><th>缩写</th><th>全称</th></tr></thead>","<tbody>","<tr><td align=''>FPWD</td><td align=''>First Public Working Draft：<span style=\"background:hsl(10, 55%, 55%);color:white;\">第一份公共工作草案</span></td></tr>","<tr><td align=''>WD</td><td align=''>Working Draft：<span style=\"background:hsl(20, 78%, 55%);color:white;\">工作草案</span></td></tr>","<tr><td align=''>CR</td><td align=''>Candidate Recommendation：<span style=\"background:hsl(62, 86%, 45%);color:white;\">候选推荐</span></td></tr>","<tr><td align=''>PR</td><td align=''>Proposed Recommendation：<span style=\"background:hsl(89, 53%, 44%);color:white;\">拟定推荐</span></td></tr>","<tr><td align=''>REC</td><td align=''>Recommendation：<span style=\"background:hsl(129, 53%, 40%);color:white;\">推荐</span></td></tr>","<tr><td align=''>SPSD</td><td align=''>Superseded Recommendation：<span style=\"background:hsl(129, 53%, 40%);color:white;\">取代建议</span></td></tr>","</tbody></table>","<p>基本上，一份文档进入CR阶段，该文档极有可能成为正式的文档。</p>","<h2 id='章五：选择器-0'>章五：选择器</h2>","<h3 id='内容-0'>内容</h3>","<p><a href='#parttern-matching'>5.1 模式匹配</a></p>","<p><span id='parttern-matching'></span></p>","<h3 id=' 模式匹配-0'> 模式匹配</h3>","<p>在CSS中，<strong>模式匹配规则</strong>确定哪些样式规则适用于文档树中的元素。</p>","<p>这些模式称为<strong>选择器</strong>，范围可以从简单的HTML元素到丰富的HTML上下文。如果模式中的所有条件对于某个元素都为真，则选择器匹配该元素。</p>","<p>对于选择器，文档语言元素名称是否区分大小写取决于文档语言。例如，在HTML中，元素名称不区分大小写，但是在XML中，它们区分大小写。</p>","<p>下表总结了CSS 2.2选择器语法：</p>","<table>","<thead><tr><th>模式</th><th>含义</th><th>描述</th></tr></thead>","<tbody>","<tr><td align=''>*</td><td align=''>匹配任意元素</td><td align=''><a href='#universal-selector'>通用选择器</a></td></tr>","<tr><td align=''>E</td><td align=''>匹配任意<code>E</code>元素</td><td align=''><a href='#type-selectors'>类型选择器</a></td></tr>","<tr><td align=''>E F</td><td align=''>匹配任意<code>E</code>元素的任意后代<code>F</code>元素</td><td align=''><a href='#descendant-selectors'>后代选择器</a></td></tr>","<tr><td align=''>E>F</td><td align=''>匹配任意<code>E</code>元素的直接子元素<code>F</code></td><td align=''><a href='#child-selectors'>子类选择器</a></td></tr>","<tr><td align=''>E : first-child</td><td align=''>匹配一个元素<code>E</code>，当<code>E</code>是其父元素的第一个<code>E</code>元素</td><td align=''><a href='#first-child-pseudo-class'>first-child伪类选择器</a></td></tr>","<tr><td align=''>E : link<br>E : visited</td><td align=''>匹配一个尚未访问或已访问的超链接<code>E</code></td><td align=''><a href='#link-pseudo-class'>链接伪类选择器</a></td></tr>","<tr><td align=''>E : active<br>E : hover<br>E : focus</td><td align=''>匹配用户操作而影响的任意元素<code>E</code></td><td align=''><a href='dymic-pseudo-class'>动态伪类选择器</a></td></tr>","<tr><td align=''>E : lang(c)</td><td align=''>匹配语言为<code>c</code>的一个元素<code>E</code></td><td align=''><a href='#lang-pseudo-class'>lang伪类选择器</a></td></tr>","<tr><td align=''>E + F</td><td align=''>匹配任意紧跟在<code>E</code>之后的<code>F</code>元素</td><td align=''><a href='#adjacent-selectors'>相邻选择器</a></td></tr>","<tr><td align=''>E[attr]</td><td align=''>匹配任意拥有<code>attr</code>属性的<code>E</code>元素</td><td align=''><a href='#attribute-selectors'>属性选择器</a></td></tr>","<tr><td align=''>E[attr=\"value\"]</td><td align=''>匹配任意拥有<code>attr</code>属性，且值为<code>\"value\"</code>的<code>E</code>元素</td><td align=''><a href='#attribute-selectors'>属性选择器</a></td></tr>","<tr><td align=''>E[attr~=\"value\"]</td><td align=''>匹配任意拥有<code>attr</code>属性，且值为一个<strong>含空格</strong>的列表，该列表中含有<code>\"value\"</code>的<code>E</code>元素</td><td align=''><a href='#attribute-selectors'>属性选择器</a></td></tr>","<tr><td align=''>E[attr｜=\"value\"]</td><td align=''>匹配任意拥有<code>attr</code>属性，且值包含指定值<code>\"value\"</code>的<code>E</code>元素</td><td align=''><a href='#attribute-selectors'>属性选择器</a></td></tr>","<tr><td align=''>E.class</td><td align=''>匹配任意具有<code>class</code>类的元素</td><td align=''><a href='#class-selectors'>类选择器</a></td></tr>","<tr><td align=''>E#id</td><td align=''>匹配任意具有id为<code>id</code>的元素</td><td align=''><a href='#id-selectors'>ID选择器</a></td></tr>","</tbody></table>","<h2 id='章六：分配属性值、级联和继承-0'>章六：分配属性值、级联和继承</h2>","<h3 id='内容-1'>内容</h3>","<p><a href='#calculating-specificity'>6.4.3 计算选择器的优先级</a></p>","<p><span id='calculating-specificity'></span></p>","<h3 id='计算选择器的优先级-0'>计算选择器的优先级</h3>","<blockquote>","<p><strong>优先级：</strong></p>","<p>原文为<code>specificity</code>，可翻译为特异性、明确性、具体性等。</p>","</blockquote>","<p>选择器的优先级计算规则如下：</p>","<ul>","<li><code>a</code>：如果是来自<code>style</code>属性的内联规则，则为<code>1</code>，否则为<code>0</code></li>","<li><code>b</code>：计算选择器中<code>ID</code>属性的数量</li>","<li><code>c</code>：计算选择器中类、属性和伪类的数量</li>","<li><code>d</code>：计算选择器中元素名称和伪元素的数量</li>","</ul>","<p>优先级的计算仅基于选择器的形式。</p>","<blockquote>","<p><strong>选择器的形式：</strong></p>","<p><code>[id=\"id\"]</code>形式的选择器被记为<strong>属性选择器</strong>，而不是ID选择器，因此优先级规则为<code>a=0,b=0,c=1,d=0</code>。</p>","</blockquote>","<p>连接得到的四个数字<code>a-b-c-d</code>即可得到选择器的优先级。</p>","<blockquote>","<p><strong>注意：</strong></p>","<p>这四个数字的数字系统，即计算规则，为大基数数字系统，a具有最高的优先级，同优先级数字越大权重越高。</p>","</blockquote>","<p>下面是一些例子：</p>","<pre>","<code>li:first-line {}    优先级为：a=0, b=0, c=0, d=2    0-0-0-2</code>","<code>li.class1.class2 {}    优先级为：a=0, b=0, c=2, d=1    0-0-2-1</code>","<code>#id {}    优先级为：a=0, b=1, c=0, d=0    0-1-0-0</code>","<code>style=\"\"    优先级为：a=1, b=0, c=0, d=0    1-0-0-0</code>","</pre>","<p>需要注意的是：一条规则将整体参与优先级的计算，换句话说，即是<strong>计算某一条规则的优先级而不是计算选择器的优先级</strong>。</p>","<pre>","<code>ul li .first {}    优先级为：a=0, b=0, c=1, d=2    0-0-1-2</code>","<code>#some &gt; #ele {}    优先级为：a=0, b=2, c=0, d=0    0-2-0-0</code>","</pre>","<p>此外，某一元素继承规则的优先级总是小于本身所拥有的规则的优先级。</p>","<h2 id='章八：盒模型-0'>章八：盒模型</h2>","<h3 id='内容-2'>内容</h3>","<p><a href='#box-dimensions'>8.1 盒子尺寸</a></p>","<p><a href='#collapsing-borders'>8.3.1 折叠边距</a></p>","<p><span id='box-dimensions'></span></p>","<h3 id='盒子尺寸-0'>盒子尺寸</h3>","<p>每个盒子具有内容区域<code>content</code>和可选择的周边填充<code>padding</code>、边框<code>border</code>以及边缘区域<code>margin</code>。每个区域的大小由下面定义的属性指定。</p>","<p>下图显示了这些区域的关联方式，以及相关术语：</p>","<p><img alt='盒子尺寸的组成' title='盒子尺寸的组成' src='https://www.w3.org/TR/CSS22/images/boxdim.png' ></p>","<p>四个区域中的每一个的周长称为边缘，因此，每个框有四条边。</p>","<p>每个边框的大小为<code>0</code>时均<strong>向内收缩</strong>，从内到外的边框组成的盒子依此被定义为：内容盒子<code>content box</code> 、填充盒子<code>padding box</code>、边框盒子<code>border box</code>以及边缘盒子<code>margin box</code>。</p>","<blockquote>","<p><strong>关于box：</strong>一般来说，将<code>content box</code>中的<code>box</code>翻译为<strong>框</strong>似乎更合常理，但由于<code>border</code>已经带有边框的意思，因此这里采用<strong>盒子</strong>来翻译<code>box</code>。</p>","</blockquote>","<p>内容盒子、填充盒子与边框盒子的背景样式由元素的<code>background</code>指定，边缘盒子的背景则<strong>总是透明</strong>的。</p>","<p><span id='collapsing-borders'></span></p>","<h3 id='折叠边距-0'>折叠边距</h3>","<blockquote>","<p><strong>折叠与崩溃：</strong></p>","<p>原文为<code>collapsing</code>或<code>collapse</code>，直译为崩溃、倒塌，在此意译为折叠，便于理解。</p>","</blockquote>","<p>在CSS中，两个或多个盒子：它们可能是也可能不是兄弟，的相邻边距可以组合形成单个边距。通过这种方式结合的而得到的边距被称为折叠边距。</p>","<blockquote>","<p><strong>不是兄弟的相邻边框：</strong>这里的相邻指的是渲染过后相邻，而不单单只是DOM节点的相邻。</p>","</blockquote>","<p><strong>水平边距永不折叠。</strong></p>","<p>相邻的<strong>垂直边距</strong>将会折叠，除了以下情况：</p>","<ul>","<li>根元素框的边距不会折叠</li>","<li>如果具有间隙的元素的顶部边距与底部边距相邻，则该元素的边距将与后续兄弟的边距折叠，但是这样所产生的边距将不会与父元素的下边距折叠</li>","<li>如果一个具有非零<code>min-height</code>或高度为<code>auto</code>的盒子的上边距，与它最后一个流内子元素的下边距折叠，则该子元素的下边距不会与其父元素的下边距折叠</li>","</ul>","<p>折叠边距的计算规则如下：</p>","<ul>","<li>当两个或多个边距折叠时，生成的边距高度是参与折叠的边距高度的最大值</li>","<li>在负边距的情况下，负邻接边距的绝对值的最大值将从正邻接边距的最大值中减去</li>","<li>如果没有正边距，则用零减负邻接边距的绝对值的最大值</li>","</ul>","<p>如果盒子的顶部与底部边距相邻，即空白盒子，则边距可能会通过这个盒子进行折叠。</p>","<blockquote>","<p>了解更多关于折叠边距的知识：<a title='MDN' href='https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing'>MDN</a></p>","</blockquote>","<h4 id='解决方法-0'>解决方法</h4>","<p>注：本节内容属于额外内容。</p>","<p>从定义中可以抽离出发生折叠边距的三个条件：</p>","<ol start='1'>","<li>普通流</li>","<li>两个或多个</li>","<li>相邻</li>","<li>垂直方向</li>","</ol>","<p>破坏这四个条件之一，即可阻止折叠边距的发生，常用的方法有如下几种：</p>","<ol start='1'>","<li>","<p>破坏普通流：</p>","<p>父元素创建BFC（根元素、浮动元素、绝对定位元素、不是块元素的块级容器<code>inline-block; table-cell; table-caption</code>、<code>overflow</code>值不为<code>visible</code>）</p>","</li>","</ol>","<ol start='2'>","<li>","<p>破坏 margin 的直接相邻：</p>","<p>使用<code>padding</code>、使用透明边框<code>border</code></p>","</li>","</ol>","<h2 id='章九：可视格式化模型-0'>章九：可视格式化模型</h2>","<h3 id='内容-3'>内容</h3>","<p><a href='#containing-blocks'>9.1.2 包含块</a></p>","<p><a href=\"#controlling-box-generation\">9.2 控制盒子生成</a></p>","<p><a href=\"#block-level-elements\">9.2.1 块级元素和块盒</a></p>","<p><a href='#normal-flow'>9.4 普通流</a></p>","<p><a href='#block-formatting-contexts'>9.4.1 块格式化上下文</a></p>","<p><a href='#inline-formatting-contexts'>9.4.2 内联格式化上下文</a></p>","<p><a href='#relative-positioning'>9.4.3 相对定位</a></p>","<p><a href='#floats'>9.5 浮动</a></p>","<p><a href='#float-property'>9.5.1 定位浮动：float属性</a></p>","<p><a href=\"#clear-property\">9.5.2 控制浮动旁的流：clear属性</a></p>","<p><a href=\"#absolute-positioning\">9.6 绝对定位</a></p>","<p><a href=\"#fixed-position\">9.6.1 固定定位</a></p>","<p><a href=\"#relationships-between-d-p-f\">9.7 display、position与float之间的联系</a></p>","<p><a href='#zIndex-property'>9.9.1 指定堆栈级别：z-index属性</a></p>","<p><span id='containing-blocks'></span></p>","<h3 id='包含块-0'>包含块</h3>","<p>在CSS2.2中，许多盒子的位置和大小是相对于被称为包含块的矩形框的边缘计算的。通常，生成的盒子用作一个块，去包含后代盒子。我们说一个盒子<i>建立</i>其后代的包含块。<i>一个盒子的包含块</i>指的是<i>这个盒子所在的包含块</i>，而不是这个盒子建立的包含块。</p>","<p>每个盒子都有一个相对于其包含块的位置，但它不受这个包含块的限制，这个盒子可能会溢出包含块。</p>","<p><span id=\"controlling-box-generation\"></span></p>","<h3 id='控制盒子生成-0'>控制盒子生成</h3>","<p>以下部分描述了可以在CSS2.2中生成的盒子的类型。盒子的类型部分地影响其在可视格式化模型中的行为。下面描述的<code>display</code>属性指定了一个盒子的类型。</p>","<p><code>display</code>属性的某些值导致源文档中的一个元素生成一个<strong>主盒</strong>，主盒包含了后代盒子和生成内容，主盒同时也是任何定位方案中涉及的盒子。除了主盒之外，某些元素可能会生成额外的盒子附加于主盒，这些元素是<code>list-item</code>元素。这些附加盒子相对于主盒放置。</p>","<p><span id='block-level-elements'></span></p>","<h3 id='块级元素和块盒-0'>块级元素和块盒</h3>","<p><strong>块级元素</strong>——源文档中可是化为块（例如段落）的那些元素——是生成块级主盒的那些元素。使一个元素成为块级元素的<code>display</code>的取值包括<code>block</code>、<code>list-item</code>和<code>table</code>。<strong>块级盒子</strong>是参与块格式化上下文的盒子。</p>","<p>在CSS2.2中，块级盒子也是块级容器盒子，除非它是表格盒子或者<i>替换元素</i>的主盒。<strong>块容器盒子</strong>要么只包含块级盒子、要么建立内联格式化上下文因此只包含内联级盒子。主盒是块容器盒子的元素是<strong>块容器元素</strong>。使未提换元素生成块容器的<code>display</code>的取值包括<code>block</code>、<code>list-item</code>和<code>inline-block</code>。并非所有的块容器盒子都是块级盒子：未替换的内联盒子和未提换的表格单元是块容器，但不是块级盒子（即块级元素）。块级盒子同样也是块容器的被称为<strong>块盒</strong>。</p>","<blockquote>","<p><strong>替换元素：</strong></p>","<p>HTML中的元素可以分为替换元素<code>replaced element</code>与未替换元素<code>non-replace element</code>。诸如<code>&lt;p&gt;内容&lt;/p&gt;</code>、<code>&lt;div&gt;内容&lt;/div&gt;</code>之类，起始与闭合标签中间具有内容、内容真实地渲染出来的元素，叫未替换元素；而像<code>&lt;img src=\"img.jpg\"&gt;</code>、<code>&lt;input type=\"submit\" value=\"提交\"&gt;</code>之类，没有闭合标签与内容、用属性设置如何展示的元素，叫替换元素——它们的内容<strong>被替换</strong>为额外的资源。</p>","<p>下文有涉及时会再次重复该概念。</p>","</blockquote>","<p>三个术语“块级盒子”、“块容器盒子”与“块盒”有时明确地缩写为“块”。</p>","<p><span id=\"inline-level-elements\"></span></p>","<h3 id='内联级元素和内联盒-0'>内联级元素和内联盒</h3>","<p><strong>内联级元素</strong>是源文档中不形成新内容块的元素。内容以行分布（例如，段落内的强调文本片段，内联图像等）。使一个元素成为内联元素的<code>display</code>属性的取值包括：<code>inline</code>、<code>inline-table</code>和<code>inline-block</code>。内联级元素生成<strong>内联级盒子</strong>，这些盒子参与内联格式化上下文。</p>","<p><strong>内联盒</strong>既是内联级的，并且其内容参与其包含的内联格式化上下文。<code>display</code>值为<code>inline</code>的非替换元素生成内联盒。不是内联盒的内联级别盒子（例如替换的内联级元素、<code>inline-block</code>元素、<code>inline-table</code>元素）称为<strong>原子内联级盒子</strong>，因为它们作为单个不透明盒子参与其内联格式化上下文。</p>","<p><span id='normal-flow'></span></p>","<h3 id='普通流-0'>普通流</h3>","<p>普通流中的盒子属于格式化上下文，在CSS2.2中可以是表格格式化上下文<code>table</code>、块格式化上下文<code>block</code>或者内联格式化上下文<code>inline</code>。在未来级别的CSS中，将引入其他类型的格式化上下文。</p>","<p>块级盒子参与块格式化上下文，内联盒子参与内联格式化上下文。</p>","<p><span id='block-formatting-contexts'></span></p>","<h3 id='块格式化上下文-0'>块格式化上下文</h3>","<p>浮动、绝对定位元素、不是块级元素的块级容器（如<code>inline-block</code>、<code>table-cell</code>和<code>table-caption</code>），以及<code>overflow</code>属性不是<code>visible</code>（除非该内容已传播到视口）的块级元素，将为其内容建立新的块格式化上下文。</p>","<p>在块格式化上下文中，盒子将从包含块的顶部一个接一个的垂直排列，两个兄弟盒子之间的垂直距离由它们的<code>margin</code>属性决定，块格式化上下文中相邻块级盒子的垂直边距同样折叠。</p>","<p>在块格式化上下文中，每个盒子的左外边缘紧接包含块的左边缘，除非盒子建立了新的块格式化上下文（这种情况下，盒子可能因浮动而变窄），否则即使存在浮动也同样如此（尽管盒子的线框可能因浮动而缩小）。</p>","<p><span id='inline-formatting-contexts'></span></p>","<h3 id='内联格式化上下文-0'>内联格式化上下文</h3>","<p>内联格式化上下文由不包含块级盒子的块级容器盒子建立。</p>","<p>在内联格式化上下文中，盒子将从包含块的顶部一个接一个的水平排列，这些盒子之间会考虑水平边距<code>margin</code>、边框<code>border</code>和填充<code>padding</code>。盒子可以以不同的方式垂直对齐，它们的顶部或底部都可以对齐，或者它们内部的文本基线也可以对齐。而包含形成一条线的盒子的矩形区域称为行框。</p>","<blockquote>","<p><strong>行框：</strong></p>","<p>最后一句原文为：<code>The rectangular area that contains the boxes that form a line is called a line box.</code></p>","<p>可理解为内联格式化上下文中的，每一行文本所组成的矩形区域。</p>","</blockquote>","<p>行框的宽度由包含块和浮动元素的存在确定，行框的高度由行高<code>line-height</code>给出的规则得出。</p>","<p><span id='relative-positioning'></span></p>","<h3 id='相对定位-0'>相对定位</h3>","<p>一旦一个盒子按照普通流或浮动被布局，它可以相对该位置移动，这被称之为相对定位。</p>","<p>以这种方式来偏移一个盒子<code>Box-1</code>对随后的框<code>Box-2</code>没有影响：<code>Box-2</code>的位置表现的和<code>Box-1</code>没有偏移一样，并且在<code>Box-1</code>偏移发生之后<code>Box-2</code>并不会重定位。这意味着相对定位可能导致盒子重叠，但是，如果相对定位导致了一个具有<code>overflow: auto</code>或<code>overflow: scroll</code>的盒子发生了内容溢出，则UA必须允许用户访问溢出的内容，这通常会创建滚动条，并影响到布局。</p>","<p>相对定位的盒子保持了正常的<i>流尺寸</i>，包括换行符和最初为它保留的空间。本文<strong>包含块</strong>的部分说明了相对定位的盒子何时建立了新的包含块。</p>","<p>对于相对定位的元素，<code>left</code>、<code>right</code>属性水平地移动盒子，而不改变相对定位元素的大小。<code>left</code>元素向右移动，<code>right</code>则相反。由于<code>left</code>和<code>right</code>不会分割或拉伸盒子，因此<i>生效的值</i>始终是：<code>left = -right</code>。</p>","<blockquote>","<p><strong>生效的值：</strong>最终计算的值，为一个。</p>","</blockquote>","<ul>","<li>如果<code>left</code>和<code>right</code>都是它们的初始值<code>auto</code>，则生效的值为<code>0</code></li>","<li>如果<code>left</code>是<code>auto</code>，则其生效的值是负的<code>right</code>的值，即盒子向左移动<code>right</code>的值</li>","<li>如果<code>right</code>是<code>auto</code>，则其生效的值为负的<code>left</code>的值</li>","<li>如果<code>left</code>和<code>right</code>都不是<code>auto</code>，则其位置被过度约束，其中一个值必须忽略，如果包含块的<code>direction</code>属性为<code>ltr</code>，则<code>left</code>胜出且<code>right</code>的值为<code>-left</code>；如果是<code>rtl</code>则<code>right</code>胜出，<code>left</code>属性将被忽略</li>","</ul>","<p>类似的，<code>top</code>与<code>bottom</code>属性在不改变元素大小的情况下垂直的移动盒子，生效的值始终为<code>top = -bottom</code>。如果两者都是<code>auto</code>，则其生效的值均为<code>0</code>；如果其中一个是<code>auto</code>，则按照负值计算规则计算；如果两者都不是<code>auto</code>，则忽略<code>bottom</code>，即<code>bottom</code>生效的值将减去<code>top</code>的值。</p>","<p><span id='floats'></span></p>","<h3 id='浮动-0'>浮动</h3>","<p>浮动，是一个在当前行上，向左或向右移动的盒子。浮动最有趣的特性莫过于其内容可能沿其侧边流动，可以通过其<code>clear</code>属性来禁用这一特性。</p>","<p>内容沿左浮动框的右侧向下流动，沿右浮动框的左侧向下流动。下述内容描述了<i>浮动定位</i>与<i>内容流</i>。</p>","<p>浮动的盒子向左或向右移动，直至其外边缘接触<i>包含块</i>边缘或另一个浮动元素的外边缘。如果存在<i>行框</i>，则浮动盒子的外部顶部与当前行框的顶部对齐。</p>","<p>如果没有足够的<strong>水平空间</strong>用于浮动，它将会向下移动，直至适合或没有更多的浮动元素存在。</p>","<p>由于<strong>浮动不在流中</strong>，因此在浮动盒子之前和之后创建的<i>未定位</i>块盒子垂直排列，就像浮动不存在一样。但是，会根据需要缩短浮动旁边的创建的当前及后续行框，以便为浮动的边距盒子腾出空间。</p>","<blockquote>","<p><strong>边距盒子：</strong>原文为<code>margin box</code>。</p>","</blockquote>","<p><span id=\"float-property\"></span></p>","<h3 id='定位浮动：`float`属性-0'>定位浮动：<code>float</code>属性</h3>","<table>","<thead><tr><th>名称</th><th>float</th></tr></thead>","<tbody>","<tr><td align=''>值</td><td align=''>left、right、none、inherit</td></tr>","<tr><td align=''>初始值</td><td align=''>none</td></tr>","<tr><td align=''>适用于</td><td align=''>所有元素，但参见9.7</td></tr>","<tr><td align=''>继承性</td><td align=''>无</td></tr>","<tr><td align=''>百分比</td><td align=''>N/A</td></tr>","<tr><td align=''>媒体</td><td align=''>visual</td></tr>","<tr><td align=''>计算值</td><td align=''>同给定值</td></tr>","</tbody></table>","<p><code>float</code>属性指定盒子是否应该向左，向右或根本不浮动。该属性可以在任何元素上设置，但仅适用于该元素未被<code>absolute</code>定位。此属性的值具有以下含义：</p>","<ul>","<li>","<p><code>left</code></p>","</li>","</ul>","<p>该元素生成一个浮动到左边的块级盒子，<i>其它内容</i>从盒子的右侧开始流动，从顶部开始（取决于<code>clear</code>属性）。</p>","<blockquote>","<p><strong>其它内容：</strong>指与该元素同级的其它内容，即兄弟节点</p>","</blockquote>","<ul>","<li>","<p><code>right</code></p>","</li>","</ul>","<p>类似于<code>left</code>，此时其它内容从盒子的左侧开始流动，从顶部开始。</p>","<ul>","<li>","<p><code>none</code></p>","</li>","</ul>","<p>该元素不浮动。</p>","<p>用户代理可以将根元素上的<code>float</code>视为<code>none</code>。</p>","<p>以下是控制浮动行为的<strong>精准规则</strong>：</p>","<ol start='1'>","<li>","<p>左浮动盒子的左外边缘可能不在其<i>包含块</i>的左边缘的左侧，同样的道理适用于右浮动盒子。</p>","</li>","</ol>","<blockquote>","<p><strong>包含块：</strong>由这段话我们可以对包含块进一步了解，一个盒子所在的包含块在其<code>margin</code>内部。</p>","</blockquote>","<ol start='2'>","<li>","<p>如果当前的盒子是左浮动的，并且源文档中较早的元素生成了任何左浮动盒子，则对于此类较早生成的浮动盒子，当前浮动盒子的左外边缘一定位于稍前浮动盒子的右外边缘的右边，<i>或者</i>其顶部必须低于前一个浮动盒子的底部。同样的道理适用于右浮动盒子。</p>","</li>","</ol>","<blockquote>","<p><strong>或者：</strong>父元素宽度不够时，两个浮动元素将上下排列。</p>","</blockquote>","<ol start='3'>","<li>左浮动盒子的右外边缘可能不会位于跟随它的右浮动盒子的右边。同样的道理适用于右浮动盒子。</li>","<li>浮动盒子的外顶部可能不会高于其包含块的顶部。当浮动发生在两个折叠边距之间时，浮动就好像有一个匿名的块级父元素参与<i>流</i>一样被定位。这种父级元素的位置在本文<i>折叠边距</i>一节给出了定义。</li>","</ol>","<blockquote>","<p><strong>流：</strong>由普通流这一概念可知，这里指文档的排列，它们就像流一样。</p>","</blockquote>","<ol start='5'>","<li>浮动盒子的外顶部可能不会高于源文档中较早元素生成的任何块级盒子或浮动盒子的外顶部。</li>","<li>一个元素的浮动盒子的外顶部可能不会高于源文档中较早元素生成的任何包含盒子的线框的顶部。</li>","<li>左浮动盒子的左边有另一个左浮动盒子，当前浮动盒子的右边缘可能不会位于其包含块右边缘的右边。（在宽松情况下，左边的浮动元素可能不会在其右边缘伸出，除非它已经尽可能的向左浮动）。同样的道理适用于右浮动盒子。</li>","<li>浮动盒子必须尽可能高。</li>","<li>左浮动盒子必须尽可能放置在左侧，右浮动盒子必须尽可能放置在右侧。<i>相对于更偏左或偏右的位置，倾向于选择较高的位置</i>。</li>","</ol>","<blockquote>","<p><strong>注意：</strong>原文为<code> A higher position is preferred over one that is further to the left/right.</code>。</p>","</blockquote>","<p>但是在CSS2.2中，如果在块格式化上下文中，有一个流入的负垂直边距，使得浮动元素的位置高于它所处的位置，所有这类的边距将被设置为<code>0</code>，浮动元素的将是位置未被定义的。</p>","<p>对这些规则中其它元素的引用，仅引用的是与浮动元素处于同一块格式化上下文中的元素。</p>","<p><span id=\"clear-property\"></span></p>","<h3 id='控制浮动旁的流：`clear`属性-0'>控制浮动旁的流：<code>clear</code>属性</h3>","<table>","<thead><tr><th>名称</th><th>clear</th></tr></thead>","<tbody>","<tr><td align=''>值</td><td align=''>none、left、right、both、inherit</td></tr>","<tr><td align=''>初始值</td><td align=''>none</td></tr>","<tr><td align=''>适用于</td><td align=''>块级元素</td></tr>","<tr><td align=''>继承性</td><td align=''>无</td></tr>","<tr><td align=''>百分比</td><td align=''>N/A</td></tr>","<tr><td align=''>媒体</td><td align=''>visual</td></tr>","<tr><td align=''>计算值</td><td align=''>同给定值</td></tr>","</tbody></table>","<p>本属性指示元素盒子的哪些边可能不与较早的浮动盒子相邻。<code>clear</code>属性不考虑元素内的浮动或其它块格式化上下文中的浮动。</p>","<p>应用于非浮动<strong>块级元素</strong>时，该属性的值有以下含义：</p>","<ul>","<li>","<p><code>left</code></p>","</li>","</ul>","<p>要求盒子的顶部<i>边框边缘</i>位于源文档中较早元素生成的任何左浮动盒子的底部外边缘的下方。</p>","<ul>","<li>","<p><code>right</code></p>","</li>","</ul>","<p>要求盒子的顶部边框边缘位于源文档中较早元素生成的任何右浮动盒子的底部外边缘的下方。</p>","<ul>","<li>","<p><code>both</code></p>","</li>","</ul>","<p>要求盒子的顶部边框边缘位于源文档中较早元素生成的任何左、右浮动盒子的底部外边缘下方。</p>","<ul>","<li>","<p><code>none</code></p>","</li>","</ul>","<p>盒子相对于浮动元素的位置没有约束。</p>","<p>除<code>none</code>之外的值可能会引入<i>间隙</i>，间隙抑制边距折叠，并作为元素<i>上边距</i>之上的空间。它用于将元素垂直地沿浮动元素推动。</p>","<blockquote>","<p><strong>间隙：</strong>原文为<code>clearance</code>，可翻译为净空，在此意译为间隙。</p>","<p><strong>上边距：</strong>即<code>top margin</code>。</p>","</blockquote>","<p>通过首先确定元素顶部边框边缘的假想位置，计算设置<code>clear</code>属性的元素的间隙。如果元素的<code>clear</code>属性为<code>none</code>，则这个位置就是实际顶部边框边缘的位置。</p>","<p>如果元素顶部边框边缘的假想位置没有超过相关的浮动元素，则引入间隙，折叠边距按照本文8.3.1中的规则发生。</p>","<p>然后将间隙的值设置为以下值的较大值：</p>","<ul>","<li>放置块元素边框边缘的必要值，即使含有最低浮动元素底部外边缘要清除。</li>","<li>放置块元素顶部边框边缘在其假想位置的必要值。</li>","</ul>","<p>或者，间隙精确地被设置为放置块级元素的边框边缘的必要值，即使要清除最低浮动元素的底部外边缘。</p>","<blockquote>","<p><strong>注意：</strong>间隙可以为负数或零。</p>","</blockquote>","<p>应用于浮动元素上时，会导致修改浮动元素定位规则。这导致了一个额外的约束#10：</p>","<ol start='10'>","<li>","<p>浮动的顶部外边缘必须低于所有稍早左浮动盒子的底部外边缘（<code>clear</code>取值<code>left</code>），或右浮动盒子的，或两者兼有。</p>","</li>","</ol>","<p><span id=\"absolute-positioning\"></span></p>","<h3 id='绝对定位-0'>绝对定位</h3>","<p>在绝对定位模型中，盒子相对与其包含块明确偏移。它完全从<i>普通流</i>中被移除（对其兄弟节点没有影响）。绝对定位盒子为普通流子项与绝对定位（但不是<code>fixed</code>）后代建立新的包含块。但是，绝对定位元素的内容不会围绕任何其它盒子流动。它们可能会遮挡另一个盒子的内容，或自身被遮挡，这取决于重叠盒子的堆栈级别。</p>","<p>本文对绝对定位元素，或该元素的盒子，的引用意味着元素的<code>position</code>属性具有值<code>absolute</code>或<code>fixed</code>。</p>","<p><span id=\"fixed-positioning\"></span></p>","<h3 id='固定定位-0'>固定定位</h3>","<p>固定定位是绝对定位的子类别。唯一的区别是：对于固定定位的盒子，<i>包含块</i>由视口建立。</p>","<p>对于<i>连续媒体</i>，滚动文档时固定盒子不会移动。在这方面，它们类似于固定的背景图片。</p>","<blockquote>","<p><strong>连续媒体：</strong>原文<code>continuous media</code>，即支持文档滚动的媒体介质。</p>","</blockquote>","<p>对于分页媒体，每页都会重复具有固定位置的盒子。例如，这对于在每个页面的底部放置签名很有用。如果固定定位的盒子的大小大于页面区域，它将会被剪切。在初始包含块中固定定位盒子的不可见部分将不会被打印。</p>","<p><span id=\"relationships-between-d-p-f\"></span></p>","<h3 id='`display`、`position`与`float`之间的联系-0'><code>display</code>、<code>position</code>与<code>float</code>之间的联系</h3>","<p>影响盒子生成和布局的三个属性<code>display</code>、<code>position</code>与<code>float</code>的交互如下：</p>","<ol start='1'>","<li>如果<code>display</code>为<code>none</code>，则<code>position</code>与<code>float</code>不适用。在这种情况下，元素不生成盒子。</li>","<li>否则，如果<code>position</code>的值为<code>absolute</code>或<code>fixed</code>，则该盒子绝对定位，<code>float</code>属性的计算值为<code>none</code>,并根据下表设置显示。盒子的位置将由<code>top</code>、<code>right</code>、<code>bottom</code>和<code>left</code>属性以及该盒子的包含块确定。</li>","<li>否则，如果<code>float</code>的值不是<code>none</code>，该盒子将会浮动并且<code>display</code>属性将会按照下表设置。</li>","<li>否则，如果该元素是根元素，则根据下表设置<code>display</code>属性，在CSS2.2中未被定义的值或者值为<code>list-item</code>将会被计算为<code>block</code>或<code>list-item</code>。</li>","<li>否则，余下的<code>display</code>属性将被应用。</li>","</ol>","<p>表格如下：</p>","<table>","<thead><tr><th>给定值</th><th>计算值</th></tr></thead>","<tbody>","<tr><td align=''>inline-table</td><td align=''>table</td></tr>","<tr><td align=''>inline、inline-block、table-row-group、table-column、table-column-group、table-header-group、table-footer-group、table-row、table-cell、table-caption</td><td align=''>block</td></tr>","<tr><td align=''>其它</td><td align=''>与给定值相同</td></tr>","</tbody></table>","<p><span id=\"zIndex-property\"></span></p>","<h3 id='指定堆栈级别：`z-index`属性-0'>指定堆栈级别：<code>z-index</code>属性</h3>","<table>","<thead><tr><th>名称</th><th>z-index</th></tr></thead>","<tbody>","<tr><td align=''>值</td><td align=''>auto、整数、inherit</td></tr>","<tr><td align=''>初始值</td><td align=''>auto</td></tr>","<tr><td align=''>适用于</td><td align=''>定位元素</td></tr>","<tr><td align=''>继承性</td><td align=''>无</td></tr>","<tr><td align=''>百分比</td><td align=''>N/A</td></tr>","<tr><td align=''>媒体</td><td align=''>visual</td></tr>","<tr><td align=''>计算值</td><td align=''>同给定值</td></tr>","</tbody></table>","<p>对于<i>定位盒子</i>，<code>z-index</code>属性指定：</p>","<ol start='1'>","<li>当前堆叠上下文中盒子的堆栈级别</li>","<li>盒子是否建立堆叠上下文</li>","</ol>","<blockquote>","<p><strong>定位盒子：</strong>即定位元素，<code>position</code>属性取<code>static</code>以外的元素。</p>","</blockquote>","<p>值具有以下含义：</p>","<ul>","<li>","<p>整数</p>","</li>","</ul>","<p>此整数是当前堆叠上下文中生成盒子的堆栈级别。该盒子同时会建立新的堆叠上下文。</p>","<ul>","<li>","<p>auto</p>","</li>","</ul>","<p>当前堆叠上下文中生成盒子的堆栈级别为<code>0</code>。如果盒子具有<code>position : fixed</code>属性，或者它是根，则它会建立新的堆叠上下文。</p>","<blockquote>","<p><strong>注意：</strong>在本节中，表达 ”在...之前” 意味着当用户面向屏幕时更接近用户。</p>","</blockquote>","<p>在CSS2.2中，每个框都有三个维度的位置。除了它们的水平和垂直位置外，盒子们沿着Z轴排列并且一个在另一个上面格式化。当盒子们在视觉上重叠时，Z轴位置十分重要。本节讨论如何沿着Z轴对盒子进行定位。</p>","<p>堆叠上下文描述了渲染树在画布上绘制的顺序。堆叠上下文可以包含更多的堆叠上下文。从父堆叠上下文的角度来看，堆叠上下文是原子的，其它堆叠上下文中的盒子可能不在当前堆叠上下文的任何盒子之间。</p>","<p>每个盒子属于一个<strong>堆叠上下文</strong>。给定堆叠上下文中的每个定位盒子具有一个整数的<strong>堆栈级别值</strong>，这是其在Z轴上相对于同一堆叠上下文中的其它堆栈级别的位置。具有更高堆栈级别的盒子总是在具有较低堆栈级别的盒子前面格式化。盒子可能有负的堆栈级别。堆栈上下文中具有相同堆栈级别的盒子根据文档树顺序<i>从后到前</i>堆叠。</p>","<blockquote>","<p><strong>从后到前：</strong>浏览器解析从上到下地文档。</p>","</blockquote>","<p>根元素形成根堆叠上下文。其它堆叠上下文由除具有<code>auto</code>之外的<code>z-index</code>的计算值的任何<i>定位元素</i>生成。堆叠上下文不一定与包含块有关。在未来的CSS级别中，其它属性可能会引入堆叠上下文，例如<code>opacity</code><a title='[CSS3COLOR]' href='https://www.w3.org/TR/CSS22/refs.html#ref-CSS3COLOR'>[CSS3COLOR]</a>。</p>","<p>在每个堆叠上下文中，以下层级将会从后到前绘制。</p>","<ol start='1'>","<li>形成堆叠上下文的元素背景<code>background</code>和边框<code>border</code>。</li>","<li>拥有负堆栈级别的子堆叠上下文（负值越小越靠下）。</li>","<li>流中的、非内联级别的非定位的后代。</li>","<li>未定位的浮动元素。</li>","<li>流中的、内联级别的非定位后代，包括<code>inline table</code>和<code>inline block</code>。</li>","<li>堆栈级别为0的子堆叠上下文和堆栈级别为0的已定位后代。</li>","<li>具有证堆栈级别的子堆叠上下文（正值越小越靠下）。</li>","</ol>","<p>在每个堆叠上下文中，堆栈级别为0的定位元素（第6层），未定位浮动元素（第4层），<code>inline block</code>（第5层）和<code>inline table</code>（第5层）被绘制为好像这些元素本身生成了新堆叠上下文，除了它们的定位后代和任何可能的子堆叠上下文参与当前的堆叠上下文。</p>","<p>此绘制顺序以递归的方式应用于每个堆叠上下文。</p>","<h2 id='章十：可视格式化上下文细节-0'>章十：可视格式化上下文细节</h2>","<h3 id='内容-4'>内容</h3>","<p><a href=\"#definition-of-containing-block\">10.1 包含块的定义</a></p>","<p><a href='#the-width-property'>10.2 内容宽度：width属性</a></p>","<p><a href=\"#calculating-widths-and-margins\">10.3 计算宽度和边距</a></p>","<p><span id=\"definition-of-containing-block\"></span></p>","<h3 id='包含块的定义-0'>包含块的定义</h3>","<p>元素框的位置和大小有时候是相对于某个矩形计算的，这个矩形被称为元素的<strong>包含块</strong>。元素的包含块定义如下：</p>","<ol start='1'>","<li>","<p>根元素所在的包含块是一个被称为<strong>初始包含块</strong>的矩形。对于连续媒体，它具有视口的尺寸并锚定在渲染画布原点；它是分页媒体的页面区域。初始包含块的<code>direction</code>属性与根元素的<code>direction</code>属性相同。</p>","</li>","</ol>","<ol start='2'>","<li>","<p>对于其它元素，如果元素的<code>position</code>属性是<code>relative</code>或<code>static</code>，则包含块由最近的祖先盒子的<i>内容边缘</i>生成，该祖先盒子是块级容器或建立块格式化上下文。</p>","<blockquote>","<p><strong>内容边缘</strong>：原文为<code>content edge</code></p>","</blockquote>","</li>","</ol>","<ol start='3'>","<li>","<p>如果元素的<code>position</code>属性为<code>fixed</code>，则在连续媒体的情况下由视口建立包含块；或者在分页媒体的情况下由视图区域建立包含块。</p>","</li>","</ol>","<ol start='4'>","<li>","<p>如果元素的<code>position</code>属性为<code>absolute</code>，则包含块由最近的祖先盒子建立，该祖先盒子的<code>position</code>属性为<code>absolute</code>、<code>relative</code>或<code>fixed</code>，建立的方式如下：</p>","<ol start='1'>","<li>在祖先是内联元素的情况下，包含块是围绕为该元素生成的第一个和最后一个内联盒子的填充框周围的边界盒子。在CSS2.2中，如果内联元素被分割为多行，则包含块是<code>undefined</code>。</li>","<li>否则包含块由祖先的<i>填充边缘</i>形成。</li>","</ol>","<blockquote>","<p><strong>填充边缘：</strong>原文为<code>padding edge</code></p>","</blockquote>","<p>如果没有这样的祖先，则包含块是初始包含块。</p>","</li>","</ol>","<p>在分页媒体中，绝对定位的元素相对于其包含块被定位，忽略任何的分页符（就像文档是连续的一样）。随后可以将该元素分为几页。</p>","<p>对于绝对定位的内容，解析到它的位置在除正在布局的页面以外的页面上（即当前页面），或解析到它的位置在当前页面上已经渲染用于打印的位置，打印机可以放置该内容：</p>","<ul>","<li>在当前页面的另一个位置</li>","<li>在后续页面上</li>","<li>可以忽略它</li>","</ul>","<p><span id=\"#the-width-property\"></span></p>","<h3 id='内容宽度：`width`属性-0'>内容宽度：<code>width</code>属性</h3>","<table>","<thead><tr><th>名称</th><th>width</th></tr></thead>","<tbody>","<tr><td align=''>值</td><td align=''>长度、百分比、auto、inherit</td></tr>","<tr><td align=''>初始值</td><td align=''>auto</td></tr>","<tr><td align=''>适用于</td><td align=''>所有元素，除了未替换的内联元素、表行<code>table-row</code>和行组<code>row-groups</code></td></tr>","<tr><td align=''>继承性</td><td align=''>无</td></tr>","<tr><td align=''>百分比</td><td align=''>指包含块的宽度</td></tr>","<tr><td align=''>媒体</td><td align=''>visual</td></tr>","<tr><td align=''>计算值</td><td align=''>给定的百分比或<code>auto</code>或绝对长度</td></tr>","</tbody></table>","<p>此属性指定盒子的<i>内容宽度</i>。</p>","<blockquote>","<p><strong>内容宽度：</strong>原文为<code>content width</code></p>","</blockquote>","<p>此属性不适用于<i>未替换</i>的内联元素。未替换的内联元素盒子的内容宽度是其中呈现内容的宽度（在子元素的任何相对偏移之前）。回想内联盒子流入线框。线框的宽度由其包含块给出，但可能因为浮动而缩短。</p>","<blockquote>","<p><strong>未提换：</strong>原文为<code>non-replace</code>。</p>","<p>HTML中的元素可以分为替换元素<code>replaced element</code>与未替换元素<code>non-replace element</code>。诸如<code>&lt;p&gt;内容&lt;/p&gt;</code>、<code>&lt;div&gt;内容&lt;/div&gt;</code>之类，起始与闭合标签中间具有内容、内容真实地渲染出来的元素，叫未提换元素；而像<code>&lt;img src=\"img.jpg\"&gt;</code>、<code>&lt;input type=\"submit\" value=\"提交\"&gt;</code>之类，没有闭合标签与内容、用属性设置如何展示的元素，叫替换元素——它们的内容<strong>被替换</strong>为额外的资源。</p>","</blockquote>","<p>该属性的值具有以下含义：</p>","<ul>","<li>","<p><strong>长度</strong></p>","</li>","</ul>","<p>使用长度单位指定内容区域的宽度。</p>","<ul>","<li>","<p><strong>百分比</strong></p>","</li>","</ul>","<p>指定百分比宽度。百分比是根据生成盒子的包含块的宽度计算的。如果包含块的宽度取决于此元素的宽度，则在CSS2.2中的结果布局为<code>undefined</code>。</p>","<blockquote>","<p><strong>注意：</strong>对于其包含块基于块级容器元素A的绝对定位元素B，百分比是根据A元素的填充框的宽度计算的。这是对CSS1的改变，其中百分比宽度始终相对于父元素的内容框计算。</p>","</blockquote>","<ul>","<li>","<p>auto</p>","</li>","</ul>","<p>宽度取决于其它属性的值。请参阅以下部分。</p>","<p>负值的宽度是非法的。</p>","<p><span id=\"calculating-widths-and-margins\"></span></p>","<h3 id='计算宽度和边距-0'>计算宽度和边距</h3>","<p>用于布局的元素的<code>width</code>、<code>margin-left</code>、<code>margin-right</code>、<code>left</code>和<code>right</code>属性的值，取决于生成的盒子的类型以及彼此的类型。（用于布局的值有时也称为使用值。）原则上，使用的值与计算值相同，而<code>auto</code>被替换为某个合适的值，百分比基于包含块计算。但是总有例外，需要区分下述情况：</p>","<ol start='1'>","<li>内联、未替换元素</li>","<li>内联、替换元素</li>","<li>普通流中的块级、未提换元素</li>","<li>普通流中的块级、替换元素</li>","<li>浮动、未提换元素</li>","<li>浮动、替换元素</li>","<li>绝对定位、未替换元素</li>","<li>绝对定位、替换元素</li>","<li>普通流中的<code>inline-block</code>、未提换元素</li>","<li>普通流中的<code>inline-block</code>、替换元素</li>","</ol>","<p>对于点1-6和9-10，在相对定位元素的情况下，<code>left</code>与<code>right</code>的值由<a href=\"#relative-positioning\">9.4.3小节：相对定位</a>中的规则给出。</p>","<blockquote>","<p><strong>注意：</strong>下面计算的<code>width</code>的使用值是暂定值，可能需要多次计算，具体取决于<code>max-width</code>与<code>min-width</code>，请参阅下面的最小宽度、最大宽度一节。</p>","</blockquote>","<p>以下为计算细节：</p>","<ol start='1'>","<li>","<p>内联、未替换元素</p>","<p><code>width</code>属性不适用。取值为auto的<code>margin-left</code>或<code>margin-right</code>属性的计算值为0。</p>","</li>","</ol>","<ol start='2'>","<li>","<p>内联、替换元素</p>","<p>取值为auto的<code>margin-left</code>或<code>margin-right</code>属性的计算值为0。</p>","<p>如果<code>height</code>和<code>width</code>都具有auto的计算值，并且元素具有固定宽度，则该固定宽度就是<code>width</code>属性的使用值。</p>","<p>如果<code>height</code>和<code>width</code>都具有auto的计算值，并且元素不具有固定宽度，但是具有固定高度和固有比例；或者<code>width</code>属性的计算值为auto，<code>height</code>的计算值为其他值，并且元素确实具有固有比例。那么<code>width</code>属性的使用值为：</p>","<p>$(height的使用值) * 固有比例$</p>","<p>如果<code>height</code>和<code>width</code>都具有auto的计算值，并且元素具有固有比例，但是没有固有宽度和高度，则在CSS 2.2中，此<code>width</code>为undefined。但是，如果包含块的宽度本身不取决于替换元素的宽度，则<code>width</code>属性的使用值是根据普通流中块级未替换元素的约束方程式计算得出的。</p>","<p>否则，如果<code>width</code>属性的计算值为auto，并且元素具有固有宽度，则该元素的固有宽度就是<code>width</code>属性的使用值。</p>","<p>否则，如果<code>width</code>属性的计算值为auto，但不满足任何上述条件，则<code>width</code>属性的使用值将变为300px。如果300px太宽而无法适应设备，则<i>UA</i>应使用具有$2 : 1$比例的最大矩形的宽度来代替设备。</p>","</li>","</ol>","<ol start='3'>","<li>","<p>普通流中的块级、未替换元素</p>","<p><code>width</code>属性的使用值与内联替换元素相同。之后，将未替换块级元素的规则应用于确定边距。</p>","</li>","</ol>","<ol start='4'>","<li>","<p>浮动、未替换元素</p>","<p>如果<code>margin-left</code>、<code>margin-right</code>属性的计算值为auto，则它们的使用值为0。</p>","<p>如果<code>width</code>属性的计算值为auto，则使用值为：缩小至适合宽度。</p>","<p>缩小至适合宽度的计算类似于使用自动表格布局算法计算表格单元格的宽度。粗略地来说：通过格式化内容而不在出现明确的换行符的地方换行而不折断来计算首选宽度，并且还可以通过尝试所有可能的换行符来计算首选的最小宽度。CSS 2.2没有定义确切的算法。第三则是找到可用宽度：在这种情况下，用包含块的宽度减去所使用的<code>margin-left</code>、<code>border-left-width</code>、<code>padding-left</code>、<code>padding-right</code>、<code>border-right-width</code>、<code>margin-right</code>以及任何相关滚动条的宽度。</p>","<p>所以，缩小至适合宽度为：$min( max(首选最小宽度, 可用宽度),首选宽度)$。</p>","</li>","</ol>","<h2 id='声明-0'>声明</h2>","<p>本篇文章源自<a title='W3C官网' href='https://www.w3.org/TR/CSS22/'>W3C官网</a>，由<a title='c1er' href='kexiezhang@gmail.com'>c1er</a>翻译与润色。</p>"]},{"id":1589289846997,"comment":{"title":"CSS预处理器——Less","date":"2019-12-04 18:05:42","tags":"-CSS","categories":"-前端知识"},"summary":["<p>Less Is More ?</p>"],"author":"","anchors":[{"id":"变量-0","level":2,"text":"变量"},{"id":"变量的声明-0","level":3,"text":"变量的声明"},{"id":"变量的使用-0","level":3,"text":"变量的使用"},{"id":"变量变量-0","level":3,"text":"变量变量"},{"id":"惰性加载-0","level":3,"text":"惰性加载"},{"id":"属性作为变量（新）-0","level":3,"text":"属性作为变量（新）"},{"id":"父选择器-0","level":2,"text":"父选择器"},{"id":"多次&-0","level":3,"text":"多次&"},{"id":"更改选择器顺序-0","level":3,"text":"更改选择器顺序"},{"id":"组合探索-0","level":3,"text":"组合探索"},{"id":"扩展-0","level":2,"text":"扩展"},{"id":"扩展语法-0","level":3,"text":"扩展语法"},{"id":"扩展附加到选择器-0","level":3,"text":"扩展附加到选择器"},{"id":"扩展内部规则集-0","level":3,"text":"扩展内部规则集"},{"id":"扩展嵌套选择器-0","level":3,"text":"扩展嵌套选择器"},{"id":"属性合并-0","level":2,"text":"属性合并"},{"id":"逗号属性合并-0","level":3,"text":"逗号属性合并"},{"id":"空格属性合并-0","level":3,"text":"空格属性合并"},{"id":"混合-0","level":2,"text":"混合"},{"id":"不输出混合-0","level":3,"text":"不输出混合"},{"id":"混合中的选择器-0","level":3,"text":"混合中的选择器"},{"id":"命名空间-0","level":3,"text":"命名空间"},{"id":"受保护的命名空间-0","level":3,"text":"受保护的命名空间"},{"id":"!important关键字-0","level":3,"text":"!important关键字"},{"id":"参数-0","level":3,"text":"参数"},{"id":"带有单个参数的混合-0","level":4,"text":"带有单个参数的混合"},{"id":"带有多个参数的混合-0","level":4,"text":"带有多个参数的混合"},{"id":"具名参数-0","level":4,"text":"具名参数"},{"id":"@arguments变量-0","level":4,"text":"@arguments变量"},{"id":"高级参数和@rest变量-0","level":4,"text":"高级参数和@rest变量"},{"id":"模式匹配-0","level":3,"text":"模式匹配"}],"content":["<p>说实话我更愿意学stylus，真的。</p>","<h2 id='变量-0'>变量</h2>","<p>一处定义，多处使用。变量好处不仅在于减少了代码编写工作，同样也减少了代码维护的成本——得益于Less的@import，我们完全可以把常用的变量存放在一个文件里，单独进行维护。</p>","<h3 id='变量的声明-0'>变量的声明</h3>","<p>使用规则<code>@变量名 : 值</code>的形式声明一个Less变量。</p>","<h3 id='变量的使用-0'>变量的使用</h3>","<ul>","<li>","<p>CSS规则</p>","<p>在规则里使用是变量最长用的使用方式之一。</p>","<pre>","<code>@color : #999;</code>","<code>.color {</code>","<code>    background-color : @color;</code>","<code>}</code>","<code>//导出</code>","<code>.color {</code>","<code>    background-color : #999;</code>","<code>}</code>","</pre>","</li>","</ul>","<ul>","<li>","<p>选择器名称</p>","<pre>","<code>@name : color;</code>","<code>.@{name} {</code>","<code>    color : black;</code>","<code>}</code>","<code>//导出</code>","<code>.color {</code>","<code>    color : black;</code>","<code>}</code>","</pre>","</li>","</ul>","<ul>","<li>","<p>URL</p>","<pre>","<code>@imgBase : 'imgBase';</code>","<code>.img {</code>","<code>    background : url('@{imgBase}/one.png') no-repeat;</code>","<code>}</code>","<code>//导出</code>","<code>.img {</code>","<code>  background: url('imgBase/one.png') no-repeat;</code>","<code>}</code>","</pre>","</li>","</ul>","<ul>","<li>","<p>@import语句</p>","<pre>","<code>@themeBase : '../themeBase';</code>","<code>@<span class='hl-keyword'>import</span> '@{themeBase}/blueTheme.less';</code>","</pre>","</li>","</ul>","<ul>","<li>","<p>属性名</p>","<pre>","<code>@m : marg<span class='hl-keyword'>in</span>;</code>","<code>.color {</code>","<code>    @{m} : auto 0;</code>","<code>}</code>","<code>//导出</code>","<code>.color {</code>","<code>  marg<span class='hl-keyword'>in</span>: auto 0;</code>","<code>}</code>","</pre>","</li>","</ul>","<h3 id='变量变量-0'>变量变量</h3>","<p>less支持使用另一个变量来定义变量的名称。</p>","<pre>","<code>@red : red;</code>","<code>.color {</code>","<code>    @color : red;</code>","<code>    .red {</code>","<code>        color : @@color;</code>","<code>    }</code>","<code>}</code>","<code>//导出</code>","<code>.color .red {</code>","<code>  color: red;</code>","<code>}</code>","</pre>","<h3 id='惰性加载-0'>惰性加载</h3>","<p>变量在使用之前不必声明。</p>","<pre>","<code>.lazy {</code>","<code>    marg<span class='hl-keyword'>in</span> : @m;</code>","<code>    @m : @mg;</code>","<code>}</code>","<code>@mg : 0 auto;</code>","<code>//导出</code>","<code>.lazy {</code>","<code>  marg<span class='hl-keyword'>in</span>: 0 auto;</code>","<code>}</code>","</pre>","<p>多次定义变量时，使用从当前作用域（如无则向上搜索）的变量的最后定义，就像CSS本身所做的那样。</p>","<h3 id='属性作为变量（新）-0'>属性作为变量（新）</h3>","<p>将属性作为变量有时会让你的代码更轻量一点，语法为<code>$属性名</code>。</p>","<pre>","<code>.color {</code>","<code>    color : red;</code>","<code>    background-color : $color;</code>","<code>}</code>","<code>//导出</code>","<code>.color {</code>","<code>  color: red;</code>","<code>  background-color: red;</code>","<code>}</code>","</pre>","<p>就像变量一样，Less将会选择当前/父范围内的最后一个属性作为“最终”值。</p>","<h2 id='父选择器-0'>父选择器</h2>","<p>使用<code>&</code>符号来获取父选择器的名称，该符号表示嵌套规则的父选择器，在将伪类应用于现有选择器时、基于现有选择器名称生成其它选择器名称时最常用。</p>","<pre>","<code>.color {</code>","<code>    color : black;</code>","<code>    &:after {  //中间不能添加空格</code>","<code>        content : '';</code>","<code>    }</code>","<code>}</code>","<code>//导出</code>","<code>.color {</code>","<code>  color: black;</code>","<code>}</code>","<code>.color:after {</code>","<code>  content: '';</code>","<code>}</code>","</pre>","<h3 id='多次&-0'>多次&</h3>","<p><code>&</code>符号能够在选择器中出现多次，这使得可以重复引用父选择器而无需重复其名称。</p>","<pre>","<code>.color {</code>","<code>    & &gt; &-blue {</code>","<code>        color : blue;</code>","<code>    }</code>","<code>}</code>","<code>//导出</code>","<code>.color &gt; .color-blue {</code>","<code>  color: blue;</code>","<code>}</code>","</pre>","<p>需要注意的是，<code>&</code>符号获取的父选择器名称不止一层，而是所有层级。</p>","<h3 id='更改选择器顺序-0'>更改选择器顺序</h3>","<p>将选择器放在继承的父选择器之前可能很有用（能够通过这个方法增加选择器的优先级），特别是该选择器被多处使用时，通过将<code>&</code>符号放在当先选择器后面来实现这一功能。</p>","<pre>","<code>.color {</code>","<code>    .input &gt; & {</code>","<code>        color : black;</code>","<code>    }</code>","<code>    color : red;</code>","<code>}</code>","<code>//导出</code>","<code>.color {</code>","<code>  color: red;</code>","<code>}</code>","<code>.input &gt; .color {</code>","<code>  color: black;</code>","<code>}</code>","</pre>","<h3 id='组合探索-0'>组合探索</h3>","<p><code>&</code>符号也可用于生成逗号分隔列表中的所有可能排列，通过在逗号选择器下使用<code>&</code>符号实现。</p>","<p>这个功能怎么感觉这么鸡肋呢？</p>","<pre>","<code>a, input{</code>","<code>    & &gt; & {</code>","<code>        color : black;</code>","<code>    }</code>","<code>}</code>","<code>//导出</code>","<code>a &gt; a,</code>","<code>a &gt; input,</code>","<code>input &gt; a,</code>","<code>input &gt; input {</code>","<code>  color: black;</code>","<code>}</code>","</pre>","<h2 id='扩展-0'>扩展</h2>","<p>扩展（Extend）是一个Less伪类，该伪类调用一个选择器，以逗号分隔符合并该伪类所在的选择器与调用的选择器，选择器的规则为伪类调用选择器的规则。</p>","<pre>","<code>ul li {</code>","<code>    &:extend(.color);  //注意，Less伪类不能单独使用</code>","<code>    list-style : <span class='hl-object'>none</span>;</code>","<code>}</code>","<code>.color {</code>","<code>    color : black;</code>","<code>}</code>","<code>//导出</code>","<code>ul li {</code>","<code>  list-style: <span class='hl-object'>none</span>;</code>","<code>}</code>","<code>.color,</code>","<code>ul li {</code>","<code>  color: black;</code>","<code>}</code>","</pre>","<h3 id='扩展语法-0'>扩展语法</h3>","<p>扩展要么附加到选择器，要么放置在规则中。附加到选择器中时，它看起来像是一个伪类，同时可以选择性的加上参数all。</p>","<p>参数all代表扩展所有的<code>'.b'</code>实例，例如<code>'.a.b'</code>、<code>'.b.c'</code>。</p>","<pre>","<code>.a:extend(.b all) {</code>","<code>    color : white;</code>","<code>}</code>","<code>.b {</code>","<code>    background-color: black;</code>","<code>}</code>","<code>//导出</code>","<code>.a {</code>","<code>  color: white;</code>","<code>}</code>","<code>.b,</code>","<code>.a {</code>","<code>  background-color: black;</code>","<code>}</code>","</pre>","<h3 id='扩展附加到选择器-0'>扩展附加到选择器</h3>","<p>附加到选择器的扩展看起来像一个普通的伪类，但带有选择器作为参数。一个选择器可以包含多个extend子句，但是所有的扩展都必须在选择器的末尾。</p>","<ul>","<li>在选择器之后扩展：<code>.a:hover:extend(.b)</code></li>","<li>选择器和扩展之间的空格是允许的：<code>.a:hover :extend(.b)</code></li>","<li>多重扩展是允许的：<code>.a:hover :extend(.b) :extend(.c)</code>，这等价于<code>.a:hover :extend(.b, .c)</code></li>","<li>所有的扩展必须放在选择器的末尾</li>","</ul>","<p>如果规则集包含多个选择器，则它们中的任何一个都可以使用扩展。</p>","<h3 id='扩展内部规则集-0'>扩展内部规则集</h3>","<p>可以使用<code>&:extend(selector)</code>语法将extend放入规则集的主体中。将扩展放置到规则主体中，是将其放入该规则集的每个选择器的快捷方式。</p>","<pre>","<code>div, a {</code>","<code>    &:extend(.colorful);</code>","<code>}</code>","<code>.colorful {</code>","<code>    color : black;</code>","<code>}</code>","<code>//导出</code>","<code>.colorful,</code>","<code>div,</code>","<code>a {</code>","<code>  color: black;</code>","<code>}</code>","</pre>","<h3 id='扩展嵌套选择器-0'>扩展嵌套选择器</h3>","<p>扩展能够匹配嵌套的选择器，即<code>extend()</code>的参数支持嵌套选择器。</p>","<p>从本质上讲，扩展将查看已编译的CSS，而不是原生的Less。</p>","<pre>","<code>div {</code>","<code>    .color {</code>","<code>        color : black;</code>","<code>    }</code>","<code>}</code>","<code>.colorful:extend(div .color);</code>","<code>//导出</code>","<code>div .color,</code>","<code>.colorful {</code>","<code>  color: rebeccapurple;</code>","<code>}</code>","</pre>","<h2 id='属性合并-0'>属性合并</h2>","<p>合并功能允许将多个属性的中的规则聚合到单个属性下的逗号或空格分隔的列表中。属性合并对于<code>background</code>或<code>transform</code>之类的属性很有用。</p>","<h3 id='逗号属性合并-0'>逗号属性合并</h3>","<p>使用<code>+:</code>规则，Less将用用逗号附加属性值。</p>","<pre>","<code>.mix<span class='hl-keyword'>in</span>() {</code>","<code>    box-shadow +: 1px 0px 1px 0px #eee;  //h-shadow v-shadow blur spread color inset</code>","<code>}</code>","<code>.merge {</code>","<code>    .mix<span class='hl-keyword'>in</span>();</code>","<code>    box-shadow +: -1px 0px 1px 0px #eee;</code>","<code>}</code>","<code>//导出</code>","<code>.merge {</code>","<code>  box-shadow: 1px 0px 1px 0px #eee, -1px 0px 1px 0px #eee;</code>","<code>}</code>","</pre>","<h3 id='空格属性合并-0'>空格属性合并</h3>","<p>使用<code>+_:</code>规则，Less将用空格附加属性值。</p>","<pre>","<code>.mix<span class='hl-keyword'>in</span>() {</code>","<code>    background +_: no-repeat center;</code>","<code>}</code>","<code>.merge {</code>","<code>    .mix<span class='hl-keyword'>in</span>();</code>","<code>    background +_: url('one.png');</code>","<code>}</code>","<code>//导出</code>","<code>.merge {</code>","<code>  background: no-repeat center url('one.png');</code>","<code>}</code>","</pre>","<h2 id='混合-0'>混合</h2>","<p>使用现有样式混合出属性，类似于抽象与实例的关系。</p>","<p>可以混合使用Id选择器和类选择器。</p>","<pre>","<code>.a, #b {</code>","<code>    color : red;</code>","<code>}</code>","<code>.c {</code>","<code>    .a();</code>","<code>}</code>","<code>.d {</code>","<code>    #b();</code>","<code>}</code>","<code>//导出</code>","<code>.a,</code>","<code>#b {</code>","<code>  color: red;</code>","<code>}</code>","<code>.c {</code>","<code>  color: white;</code>","<code>  color: red;</code>","<code>}</code>","</pre>","<p>对Less的当前版本和历史版本来说，mixin调用中的括号是可选的，但是不建议使用可选的括号，在Less将来的版本中将需要使用括号。</p>","<h3 id='不输出混合-0'>不输出混合</h3>","<p>如果想创建一个mixin，但又不希望该mixin本身出现在CSS输出中，那么就需要在mixin定义后加上括号。</p>","<pre>","<code>.mix<span class='hl-keyword'>in</span> {</code>","<code>    color : red;</code>","<code>}</code>","<code>.the-mix<span class='hl-keyword'>in</span>() {</code>","<code>    color : black;</code>","<code>}</code>","<code>span {</code>","<code>    .mix<span class='hl-keyword'>in</span>();</code>","<code>    .the-mix<span class='hl-keyword'>in</span>();</code>","<code>}</code>","<code>//导出</code>","<code>.mix<span class='hl-keyword'>in</span> {</code>","<code>    color : red;</code>","<code>}</code>","<code>span {</code>","<code>  color: red;</code>","<code>  color: black;</code>","<code>}</code>","</pre>","<h3 id='混合中的选择器-0'>混合中的选择器</h3>","<p>mixin不仅可以包含属性，还可以包含选择器。</p>","<pre>","<code>.my-mix<span class='hl-keyword'>in</span>() {</code>","<code>    & &gt; div {</code>","<code>        color : #eee;</code>","<code>    }</code>","<code>}</code>","<code>p {</code>","<code>    .my-mix<span class='hl-keyword'>in</span>();</code>","<code>}</code>","<code>//导出</code>","<code>p &gt; div {</code>","<code>  color: #eee;</code>","<code>}</code>","</pre>","<h3 id='命名空间-0'>命名空间</h3>","<p>由于每个原生选择器都可以视为一个抽象，因此想在嵌套的选择器中抽出单一的规则时，需要借助选择器的命名空间，或者说作用域。</p>","<p>但是需要注意的是，元素选择器不可作为抽象来使用。</p>","<pre>","<code>.outer() {</code>","<code>    .inner {</code>","<code>        font-size : 35px;</code>","<code>    }</code>","<code>}</code>","<code>div {</code>","<code>    .outer .inner();</code>","<code>    .outer.inner();  //效果一致</code>","<code>    .outer &gt; .inner();  //效果一致</code>","<code>}</code>","<code>//导出</code>","<code>div {</code>","<code>  font-size: 35px;</code>","<code>}</code>","</pre>","<p>使用命名空间来减少与其他库混合或用户混合的冲突，这可以视为组织混合的一种方式。</p>","<h3 id='受保护的命名空间-0'>受保护的命名空间</h3>","<p>如果命名空间具有保护，则仅当保护条件返回true时，才使用由其定义的混合。命名空间保护的判断方式与混合的判断方式完全相同，因此以下两个mixin的工作方式相同：</p>","<pre>","<code>#c1er when (@theme = blue) {</code>","<code>  .mix<span class='hl-keyword'>in</span>() { }</code>","<code>}</code>","<code>#c1er {</code>","<code>  .mix<span class='hl-keyword'>in</span>() when (@theme = blue) { }</code>","<code>}</code>","<code>//导出</code>","<code>//暂时还不知到这个@theme变量是从哪里导入的，难道是从gruntfile中导入的？</code>","</pre>","<p>对于所有嵌套的命名空间和混合，Less假定<code>default()</code>具有相同的值。因此下述mixin将永远不会评估。</p>","<pre>","<code>#space_one when (<span class='hl-keyword'>default</span>()){</code>","<code>    #space_two when (<span class='hl-keyword'>default</span>()) {</code>","<code>        .mix<span class='hl-keyword'>in</span>() when not (<span class='hl-keyword'>default</span>()) { }</code>","<code>    }</code>","<code>}</code>","</pre>","<h3 id='!important关键字-0'>!important关键字</h3>","<p>在混合调用表达式后跟上<code>!important</code>关键字将会使继承该混合的规则跟上!<code>important</code>关键字。</p>","<pre>","<code>.foo (@color : #eee, @width : 100px) {</code>","<code>    width: @width;</code>","<code>    background-color: @color;</code>","<code>}</code>","<code>.unimportant {</code>","<code>    .foo();</code>","<code>}</code>","<code>.important {</code>","<code>    .foo() !important;</code>","<code>}</code>","<code>//导出</code>","<code>.unimportant {</code>","<code>  width: 100px;</code>","<code>  background-color: #eee;</code>","<code>}</code>","<code>.important {</code>","<code>  width: 100px !important;</code>","<code>  background-color: #eee !important;</code>","<code>}</code>","</pre>","<h3 id='参数-0'>参数</h3>","<h4 id='带有单个参数的混合-0'>带有单个参数的混合</h4>","<p>就像上述例子一样，混合还可以接收参数，该参数可以拥有默认值，就像函数的形参与实参那样。</p>","<pre>","<code>.border-radius(@radius : 10px) {</code>","<code>    -webkit-border-radius: @radius;</code>","<code>    -moz-border-radius: @radius;</code>","<code>    -o-border-radius: @radius;</code>","<code>}</code>","<code>.radius-<span class='hl-keyword'>default</span> {</code>","<code>    .border-radius();</code>","<code>}</code>","<code>.radius-5px {</code>","<code>    .border-radius(5px);</code>","<code>}</code>","<code>//导出</code>","<code>//当然，现在（2019/12/18）早已不需要为border-radius属性添加浏览器前缀了</code>","<code>.radius-<span class='hl-keyword'>default</span> {</code>","<code>  -webkit-border-radius: 10px;</code>","<code>  -moz-border-radius: 10px;</code>","<code>  -o-border-radius: 10px;</code>","<code>}</code>","<code>.radius-5px {</code>","<code>  -webkit-border-radius: 5px;</code>","<code>  -moz-border-radius: 5px;</code>","<code>  -o-border-radius: 5px;</code>","<code>}</code>","</pre>","<h4 id='带有多个参数的混合-0'>带有多个参数的混合</h4>","<p>使用多个参数时，可以使用逗号或分号对参数进行分隔。但是建议使用分号，这是因为逗号具有双重含义：作为混合的参数分隔符、作为CSS规则名列表的分隔符。</p>","<p>使用逗号作为混合参数的分隔符，将不再能使用逗号分隔的列表作为参数。另一方面，Less编译器在看到混合声明或调用时使用了至少一个分号，就假定混合参数使用了分号作为分隔符，逗号则被用于规则名的列表分隔。</p>","<p>下面是一些例子：</p>","<ul>","<li>两个参数，每个参数包含逗号分隔的列表：<code>.name(1, 2, 3; something, else)</code></li>","<li>三个参数，每个参数包含一个数字：<code>.name(1, 2, 3)</code></li>","<li>一个参数，包含逗号分隔CSS列表，使用伪分号创建：<code>.name(1, 2, 3;)</code></li>","<li>一个参数，有使用逗号分隔的默认值：<code>.name(@param_1: red, blue;)</code></li>","</ul>","<p>定义具有相同名称和参数数量的混合是合法的。Less将会使用所有可能适用的属性。如果使用一个参数的混合，就像<code>.mixin(red)</code>，则Less会调用所有带有一个必填参数的混合。</p>","<p>下面是一些例子：</p>","<pre>","<code>.mix<span class='hl-keyword'>in</span> (@color) {</code>","<code>    width : 100px;</code>","<code>}</code>","<code>.mix<span class='hl-keyword'>in</span> (@color, @height : 60px) {</code>","<code>    height : @height;</code>","<code>}</code>","<code>.mix<span class='hl-keyword'>in</span> (@color, @width, @height) {</code>","<code>    width : @width;</code>","<code>    height : @height;</code>","<code>    color : @color;</code>","<code>}</code>","<code>.use {</code>","<code>    .mix<span class='hl-keyword'>in</span>(red);</code>","<code>}</code>","<code>//导出</code>","<code>.use {</code>","<code>  width: 100px;</code>","<code>  height: 60px;</code>","<code>}</code>","</pre>","<h4 id='具名参数-0'>具名参数</h4>","<p>混合的引用可以通过参数名称而不是位置来提供参数值。可以通过名称来引用任何参数，而不必有任何特殊顺序。</p>","<pre>","<code>.param-named (@width : 100px; @height : 50px; @color : red) {</code>","<code>    width : @width;</code>","<code>    height : @height;</code>","<code>    background-color : @color;</code>","<code>}</code>","<code>.using {</code>","<code>    .param-named(@height : 60px; 120px)</code>","<code>}</code>","<code>//导出</code>","<code>.using {</code>","<code>  width: 120px;</code>","<code>  height: 60px;</code>","<code>  background-color: red;</code>","<code>}</code>","</pre>","<h4 id='@arguments变量-0'>@arguments变量</h4>","<p><code>@argument</code>变量在混合内部有特殊含义，指代调用混合时传入的所有参数。</p>","<pre>","<code>.<span class='hl-keyword'>arguments</span> (@url; @repeat : no-repeat) {</code>","<code>    background : @<span class='hl-keyword'>arguments</span>;</code>","<code>}</code>","<code>.using-arg {</code>","<code>    .<span class='hl-keyword'>arguments</span>('img.com/some.png'; repeat-x);</code>","<code>}</code>","<code>//导出</code>","<code>.using-arg {</code>","<code>  background: 'img.com/some.png' repeat-x;</code>","<code>}</code>","</pre>","<h4 id='高级参数和@rest变量-0'>高级参数和@rest变量</h4>","<p>使用<code>...</code>接受可变数量的参数，在变量名之后使用此命令会将变量分配给<code>@rest</code>参数。</p>","<pre>","<code>.mix<span class='hl-keyword'>in</span>(...) {        // 匹配 0-N 个变量</code>","<code>.mix<span class='hl-keyword'>in</span>() {           // 精准匹配 0 个变量</code>","<code>.mix<span class='hl-keyword'>in</span>(@a: 1) {      // 匹配 0-1 个变量</code>","<code>.mix<span class='hl-keyword'>in</span>(@a: 1; ...) { // 匹配 0-N 个变量</code>","<code>.mix<span class='hl-keyword'>in</span>(@a; ...) {    // 匹配 1-N 个变量</code>","<code>.mix<span class='hl-keyword'>in</span>(@a; @rest...) {</code>","<code>   // @rest变量绑定@a之后的变量</code>","<code>   // @<span class='hl-keyword'>arguments</span>绑定所有变量</code>","<code>}</code>","</pre>","<h3 id='模式匹配-0'>模式匹配</h3>","<p>期望随之输入参数的不同，混合的表现不同时，可以借助模式匹配来完成。严格上来讲，这只是值的一种匹配。</p>","<p>下面是一个例子：</p>","<pre>","<code>.mix<span class='hl-keyword'>in</span>-cases (c1er; @color) {</code>","<code>    .c1er()</code>","<code>}</code>","</pre>"]},{"id":1589289847000,"comment":{"title":"Markdown转义符","date":"2019-03-17 19:08:32","tags":"-Markdown","categories":"-Markdown"},"summary":["<p>关于<code>Markdown</code>中的转义符们。</p>"],"author":"","anchors":[],"content":["<p>这部分的知识属于<a title='HTML转义字符' href='www.w3chtml.com/html/character.html'>HTML转义字符</a>。</p>","<p>常见转义符列表如下：</p>","<table>","<thead><tr><th>显示结果</th><th>描述</th><th>转义符</th><th>转义编号</th></tr></thead>","<tbody>","<tr><td align=''></td><td align=''>空格</td><td align=''><code>&nbsp;</code></td><td align=''><code>&#160;</code></td></tr>","<tr><td align=''><</td><td align=''>小于号</td><td align=''><code>&lt;</code></td><td align=''><code>&#60;</code></td></tr>","<tr><td align=''>></td><td align=''>大于号</td><td align=''><code>&gt;</code></td><td align=''><code>&#62;</code></td></tr>","<tr><td align=''>&</td><td align=''>与</td><td align=''><code>&amp;</code></td><td align=''><code>&#38;</code></td></tr>","<tr><td align=''>\"</td><td align=''>双引号</td><td align=''><code>&quot;</code></td><td align=''><code>&#34;</code></td></tr>","<tr><td align=''>'</td><td align=''>单引号</td><td align=''><code>&apos;</code></td><td align=''><code>&#39;</code></td></tr>","</tbody></table>"]},{"id":1589289847028,"comment":{"title":"初识Linux","date":"2019-03-13 09:45:46","tags":"-Linux","categories":"-Linux"},"summary":["<p>作为一名程序员，不懂点Linux知识怎么说的过去？</p>","<p>本文将会随着学习的升入不断更新，介绍常用的指令及相关的知识。</p>"],"author":"","anchors":[{"id":"1.为什么要学习Linux-0","level":2,"text":"1.为什么要学习Linux"},{"id":"2.新手必须掌握的Linux命令-0","level":2,"text":"2.新手必须掌握的Linux命令"},{"id":"2.1查看帮助命令-0","level":3,"text":"2.1查看帮助命令"},{"id":"2.2常用的系统工作命令-0","level":3,"text":"2.2常用的系统工作命令"},{"id":"echo命令-0","level":4,"text":"echo命令"},{"id":"date命令-0","level":4,"text":"date命令"},{"id":"reboot命令-0","level":4,"text":"reboot命令"},{"id":"poweroff命令-0","level":4,"text":"poweroff命令"},{"id":"wget命令-0","level":4,"text":"wget命令"},{"id":"ps命令-0","level":4,"text":"ps命令"},{"id":"top命令-0","level":4,"text":"top命令"},{"id":"pidof命令-0","level":4,"text":"pidof命令"},{"id":"kill命令-0","level":4,"text":"kill命令"},{"id":"killall命令-0","level":4,"text":"killall命令"},{"id":"2.3系统状态检测命令-0","level":3,"text":"2.3系统状态检测命令"},{"id":"ifconfig命令-0","level":4,"text":"ifconfig命令"},{"id":"uname命令-0","level":4,"text":"uname命令"},{"id":"uptime命令-0","level":4,"text":"uptime命令"},{"id":"free命令-0","level":4,"text":"free命令"},{"id":"who命令-0","level":4,"text":"who命令"},{"id":"last命令-0","level":4,"text":"last命令"},{"id":"history命令-0","level":4,"text":"history命令"},{"id":"sosreport命令-0","level":4,"text":"sosreport命令"},{"id":"2.4工作目录切换命令-0","level":3,"text":"2.4工作目录切换命令"},{"id":"pwd命令-0","level":4,"text":"pwd命令"},{"id":"cd命令-0","level":4,"text":"cd命令"},{"id":"ls命令-0","level":4,"text":"ls命令"},{"id":"2.5文本文件编辑命令-0","level":3,"text":"2.5文本文件编辑命令"},{"id":"cat命令-0","level":4,"text":"cat命令"},{"id":"more命令-0","level":4,"text":"more命令"},{"id":"head命令-0","level":4,"text":"head命令"},{"id":"tail命令-0","level":4,"text":"tail命令"},{"id":"tr命令-0","level":4,"text":"tr命令"},{"id":"wc命令-0","level":4,"text":"wc命令"},{"id":"stat命令-0","level":4,"text":"stat命令"},{"id":"cut命令-0","level":4,"text":"cut命令"},{"id":"diff命令-0","level":4,"text":"diff命令"},{"id":"2.6文件目录管理命令-0","level":3,"text":"2.6文件目录管理命令"},{"id":"touch命令-0","level":4,"text":"touch命令"},{"id":"mkdir命令-0","level":4,"text":"mkdir命令"},{"id":"cp命令-0","level":4,"text":"cp命令"},{"id":"mv命令-0","level":4,"text":"mv命令"},{"id":"rm命令-0","level":4,"text":"rm命令"},{"id":"dd命令-0","level":4,"text":"dd命令"},{"id":"file命令-0","level":4,"text":"file命令"},{"id":"2.7打包压缩与搜索命令-0","level":3,"text":"2.7打包压缩与搜索命令"},{"id":"tar命令-0","level":4,"text":"tar命令"},{"id":"grep命令-0","level":4,"text":"grep命令"},{"id":"find命令-0","level":4,"text":"find命令"},{"id":"2.8其它常用命令-0","level":3,"text":"2.8其它常用命令"},{"id":"ping命令-0","level":4,"text":"ping命令"},{"id":"read命令-0","level":4,"text":"read命令"},{"id":"su命令-0","level":4,"text":"su命令"},{"id":"fdisk命令-0","level":4,"text":"fdisk命令"},{"id":"df命令-0","level":4,"text":"df命令"},{"id":"3.管道符、重定向与环境变量-0","level":2,"text":"3.管道符、重定向与环境变量"},{"id":"3.1输入输出重定向-0","level":3,"text":"3.1输入输出重定向"},{"id":"输入重定向-0","level":4,"text":"输入重定向"},{"id":"输出重定向-0","level":4,"text":"输出重定向"},{"id":"3.2管道命令符-0","level":3,"text":"3.2管道命令符"},{"id":"3.3命令行的通配符-0","level":3,"text":"3.3命令行的通配符"},{"id":"3.4常见且有用的转义字符-0","level":3,"text":"3.4常见且有用的转义字符"},{"id":"3.5重要的环境变量-0","level":3,"text":"3.5重要的环境变量"},{"id":"4.Vim编辑器与Shell命令脚本-0","level":2,"text":"4.Vim编辑器与Shell命令脚本"},{"id":"4.1Vim编辑器-0","level":3,"text":"4.1Vim编辑器"},{"id":"练习：配置主机名称、hostname命令-0","level":4,"text":"练习：配置主机名称、hostname命令"},{"id":"4.2编写Shell脚本-0","level":3,"text":"4.2编写Shell脚本"},{"id":"4.3Shell脚本的执行-0","level":3,"text":"4.3Shell脚本的执行"},{"id":"./example.sh-0","level":1,"text":"./example.sh"},{"id":"chmod u+x example.sh-0","level":1,"text":"chmod u+x example.sh"},{"id":"./example.sh-1","level":1,"text":"./example.sh"},{"id":"4.4高级Shell脚本-0","level":3,"text":"4.4高级Shell脚本"},{"id":"接收用户输入的参数-0","level":4,"text":"接收用户输入的参数"},{"id":"sh exapmle.sh one two three-0","level":1,"text":"sh exapmle.sh one two three"},{"id":"判断用户输入的参数-0","level":4,"text":"判断用户输入的参数"},{"id":"文件测试-0","level":5,"text":"文件测试"},{"id":"数值比较-0","level":5,"text":"数值比较"},{"id":"字符串比较-0","level":5,"text":"字符串比较"},{"id":"4.5流程控制语句-0","level":3,"text":"4.5流程控制语句"},{"id":"if条件测试语句-0","level":4,"text":"if条件测试语句"},{"id":"for条件循环语句-0","level":4,"text":"for条件循环语句"},{"id":"while条件循环语句-0","level":4,"text":"while条件循环语句"},{"id":"case条件测试语句-0","level":4,"text":"case条件测试语句"},{"id":"5.用户身份与文件权限-0","level":2,"text":"5.用户身份与文件权限"},{"id":"5.1用户身份与能力-0","level":3,"text":"5.1用户身份与能力"},{"id":"useradd命令-0","level":4,"text":"useradd命令"},{"id":"groupadd命令-0","level":4,"text":"groupadd命令"},{"id":"usermod命令-0","level":4,"text":"usermod命令"},{"id":"passwd命令-0","level":4,"text":"passwd命令"},{"id":"userdel命令-0","level":4,"text":"userdel命令"},{"id":"5.2文件权限与归属-0","level":3,"text":"5.2文件权限与归属"},{"id":"chmod命令-0","level":4,"text":"chmod命令"},{"id":"6.存储结构与硬盘划分-0","level":2,"text":"6.存储结构与硬盘划分"},{"id":"常见的目录划分-0","level":3,"text":"常见的目录划分"},{"id":"硬盘的命名与分区-0","level":3,"text":"硬盘的命名与分区"},{"id":"7.RAID与LVM-0","level":2,"text":"7.RAID与LVM"},{"id":"7.1独立冗余磁盘阵列のRAID-0","level":3,"text":"7.1独立冗余磁盘阵列のRAID"},{"id":"7.2逻辑卷管理器のLVM-0","level":3,"text":"7.2逻辑卷管理器のLVM"},{"id":"8.操作-0","level":2,"text":"8.操作"},{"id":"8.1判断用户输入的成绩-0","level":3,"text":"8.1判断用户输入的成绩"},{"id":"8.2切换网卡信息-0","level":3,"text":"8.2切换网卡信息"}],"content":["<h2 id='1.为什么要学习Linux-0'>1.为什么要学习Linux</h2>","<p>对于我这名梦想成为全栈工程师的人来说，学习Linux是很有必要的。从建站到深入理解Node，无一不需要我了解它常用的指令、系统架构及基本的运行原理。</p>","<p>安装Linux系统大致分为两种方式：安装<code>win+linux</code><strong>双系统</strong>或者<strong>安装虚拟机</strong>。</p>","<p>由于我比较图方便，因此使用的是第二种方式。我的配置为<code>VirtualBox+Ubuntu</code>，安装过程就不再赘述，选择这套组合的原因是——方便，<code>ubuntu</code>自带的图形化界面对刚从<code>win</code>平台转来的我们来说十分友好。</p>","<p><del>（施工完成）将在视口小于450*800的窗口显示整个页面的目录。</del></p>","<p><script></p>","<p>eval(function(p,a,c,k,e,d){e=function(c){return(c<a?'':e(parseInt(c/a)))+((c=c%a)>35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--){d[e(c)]=k[c]||e(c)}k=[function(e){return d[e]}];e=function(){return'\\\\w+'};c=1};while(c--){if(k[c]){p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c])}}return p}('\"1E 1F\";j T(){6 e=D.1G||4.Z.Y||4.F.Y,n=D.1D||4.Z.12||4.F.12;e<=1C||n<=1y?4.G(\"B\")||(R(e,n),Q({1c:\"1z-F\"})):(L(\"B\"),L(\"M\"))}j E(e){6 n=4.G(e),t=/2: b|2:b/,o=n.1A(\"x\");t.1B(o)?n.w(\"x\",o.1l(/2: b|2:b/,\"2:g\")):n.w(\"x\",o.1l(/2: g|2:g/,\"2:b\"))}D.X(\"1H\",T,!1),D.X(\"1I\",T,!1);6 L=j L(e){6 n=4.G(e);A(!n)1P!0;4.F.1x(n)},R=j R(e,n){6 t=I.H(.15<i>e),o=t,i=4.1Q(\"F\")[0],d=4.U(\"P\"),a={2:\"g\",1b:\"17\",18:t+\"h\",19:o+\"h\",k:.5</i>-t+\"h\",1p:.5<i>n-.5</i>t+\"h\",1o:\"1R%\",1a:\"1q(C,C,C,0.7)\",1O:\"1N 1J 1K 1L\",1M:\"1S\"};O(6 l 1d a){d.x[l]=a[l]}6 r=4.U(\"P\"),c={2:\"b\",1b:\"17\",18:I.H(.8<i>e)+\"h\",19:I.H(.9</i>n)+\"h\",k:I.H(.1<i>e)+\"h\",1p:I.H(.1w</i>n)+\"h\",1s:\"1t 10\",1v:\"1u\",1o:\"10\",1a:\"1q(C,C,C,0.8)\"};O(6 s 1d c){r.x[s]=c[s]}r.w(\"q\",\"B\"),d.w(\"q\",\"M\"),d.X(\"2c\",j(){E(\"B\"),E(\"M\")},!1),r.2d=j(e){e=e||D.2b,\"a\"==(e.2a||e.27).S.28()&&(E(\"B\"),E(\"M\"))},i.N(d),i.N(r)},Q=j Q(e){6 n=e.29,t=e.1c,o=e.2f,i=K 0===o?\"P\":o,d=e.2e,a=K 0===d?\"B\":d,l=K 0,r=K 0;l=n?4.G(n):4.1T(i+\".\"+t),r=4.G(a);6 c={1r:[\"2:25-g\",\"z-k:3%\",\"J:b\"],1n:[\"2:g\",\"z-k:5%\",\"J:b\"],1h:[\"2:g\",\"z-k:7%\",\"J:b\"],1g:[\"2:g\",\"z-k:9%\",\"J:b\"],1i:[\"2:g\",\"z-k:11%\",\"J:b\"],1j:[\"2:g\",\"z-k:13%\"]},s=1Y 1f();1f.26(l.1X).1W(j(e,n){[\"1r\",\"1n\",\"1h\",\"1g\",\"1i\",\"1j\"].1U(e.S)&&(e.q=e.q||e.w(\"1k\",e.W),s.1V({f:e.S,q:e.q||1k,1m:e.W}))}),1Z.20(s);O(6 m=0;m<s.24;m++){6 p=4.U(\"a\");A(p.w(\"23\",\"#\"+s[m].q),p.x=c[s[m].f].22(\";\"),p.W=s[m].1m,0!=m){A(s[m].f>s[m-1].f)s[m-1].v.N(p),s[m].v=p;V A(s[m].f==s[m-1].f)s[m-1].v.14.1e(p,16),s[m].v=p;V A(s[m].f<s[m-1].f){O(6 u=K 0,y=m-1;y>=0;y--){A(s[y].f===s[m].f){u=s[y].v;21}}u.14.1e(p,16),s[m].v=p}}V r.N(p),s[m].v=p}};',62,140,'||display||document||var|||||none||||name|block|px||function|left||||||id|||||node|setAttribute|style||margin|if|_menu|246|window|anti_display|body|getElementById|floor|Math|border|void|clearSpace|_menu_controller|appendChild|for|div|header_in_block|block_catalog|nodeName|toUse|createElement|else|innerText|addEventListener|clientWidth|documentElement|10px||clientHeight||parentNode||null|fixed|width|height|background|position|Class|in|insertBefore|Array|H4|H3|H5|H6|given_id|replace|text|H2|borderRadius|top|rgba|H1|padding|20px|auto|overflow|03|removeChild|800|post|getAttribute|test|450|innerHeight|use|strict|innerWidth|load|resize|0px|5px|grey|cursor|1px|boxShadow|return|getElementsByTagName|50|pointer|querySelector|includes|push|map|childNodes|new|console|log|break|join|href|length|inline|from|srcElement|toLowerCase|Id|target|event|click|onclick|box_id|Type'.split('|'),0,{}))</p>","<p></script></p>","<h2 id='2.新手必须掌握的Linux命令-0'>2.新手必须掌握的Linux命令</h2>","<h3 id='2.1查看帮助命令-0'>2.1查看帮助命令</h3>","<p>首先需要知道的是：命令的<strong>长格式</strong>与<strong>短格式</strong>。</p>","<table>","<thead><tr><th>格式种类</th><th></th></tr></thead>","<tbody>","<tr><td align=''>长格式</td><td align=''>man --help</td></tr>","<tr><td align=''>短格式</td><td align=''>man -h</td></tr>","</tbody></table>","<p>当我们不知道如何使用一个命令时，我们可以使用<code>man xxx</code>来看该命令的帮助。</p>","<p>想知道<code>man</code>命令的其他用法？直接使用<code>man man</code>来查看。</p>","<p>在man命令帮助信息的页面中，所包含的常用操作按键及用途如下表。</p>","<table>","<thead><tr><th>按键</th><th>作用</th></tr></thead>","<tbody>","<tr><td align=''>空格键</td><td align=''>向下翻一页</td></tr>","<tr><td align=''>Page Down</td><td align=''>向下翻一页</td></tr>","<tr><td align=''>Page Up</td><td align=''>向上翻一页</td></tr>","<tr><td align=''>home</td><td align=''>直接前往首页</td></tr>","<tr><td align=''>end</td><td align=''>直接前往页尾</td></tr>","<tr><td align=''>/</td><td align=''>从上至下搜索某个关键词，如'/linux'</td></tr>","<tr><td align=''>?</td><td align=''>从下至上搜索某个关键词，如'?linux'</td></tr>","<tr><td align=''>n</td><td align=''>定位到下一个搜索到的关键词</td></tr>","<tr><td align=''>N</td><td align=''>定位到上一个搜索到的关键词</td></tr>","<tr><td align=''>q</td><td align=''>退出帮助文档</td></tr>","</tbody></table>","<h3 id='2.2常用的系统工作命令-0'>2.2常用的系统工作命令</h3>","<p>下面介绍一些常用的系统工作命令。</p>","<h4 id='echo命令-0'>echo命令</h4>","<p>echo命令用于在终端输出字符串或变量提取后的值，格式为：<code>eco [字符串 | $变量]</code>。</p>","<h4 id='date命令-0'>date命令</h4>","<p>date用于显示及设置系统的时间或日期，格式为：<code>date [选项] [+指定的格式]</code>，<strong>注意+号</strong>。</p>","<p>date命令中的参数以及作用如下表。</p>","<table>","<thead><tr><th>参数</th><th>作用</th></tr></thead>","<tbody>","<tr><td align=''>%t</td><td align=''>跳格（Tab键）</td></tr>","<tr><td align=''>%H</td><td align=''>小时（00~23）</td></tr>","<tr><td align=''>%I</td><td align=''>小时（00~12）</td></tr>","<tr><td align=''>%M</td><td align=''>分钟（00~59）</td></tr>","<tr><td align=''>%S</td><td align=''>秒（00~59）</td></tr>","<tr><td align=''>%j</td><td align=''>今年中的第几天</td></tr>","</tbody></table>","<blockquote>","<p>Example</p>","<p>注意：当想输出空格时必须将参数写在<strong>字符串</strong>中。按照<strong>”年-月-日  小时:分钟:秒”</strong>的格式查看当前系统时间的date命令如下所示：</p>","<p><code>date \"+%Y-%m-%d %H:%M:%S\"</code></p>","</blockquote>","<h4 id='reboot命令-0'>reboot命令</h4>","<p>reboot命令用于重启系统，其格式为：<code>reboot</code>。</p>","<p><del>由于重启计算机这种操作会涉及硬件资源的管理权限，因此默认只能使用root管理员来重启。</del></p>","<p>普通用户也可以使用<code>reboot</code>。</p>","<h4 id='poweroff命令-0'>poweroff命令</h4>","<p>poweroff命令用于关闭系统，其格式为：<code>poweroff</code>。</p>","<p>普通用户同样可以使用该命令。</p>","<h4 id='wget命令-0'>wget命令</h4>","<p>wget命令用于在终端中下载网络文件，格式为：<code>wget [参数] 下载地址</code>。</p>","<p>wget命令的参数以及作用如下表。</p>","<table>","<thead><tr><th>参数</th><th>作用</th></tr></thead>","<tbody>","<tr><td align=''>-b</td><td align=''>后台下载模式</td></tr>","<tr><td align=''>-P</td><td align=''>下载到指定目录</td></tr>","<tr><td align=''>-t</td><td align=''>最大尝试次数</td></tr>","<tr><td align=''>-c</td><td align=''>端点续传</td></tr>","<tr><td align=''>-p</td><td align=''>下载页面内所有资源，包括图片、视频等</td></tr>","<tr><td align=''>-r</td><td align=''>递归下载</td></tr>","</tbody></table>","<h4 id='ps命令-0'>ps命令</h4>","<p>ps命令用于查看系统中的进程状态，格式为：<code>ps [参数]</code>。</p>","<p>ps命令的参数以及作用见下表。</p>","<table>","<thead><tr><th>参数</th><th>作用</th></tr></thead>","<tbody>","<tr><td align=''>-a</td><td align=''>显示所有进程（包括其他用户的进程）</td></tr>","<tr><td align=''>-u</td><td align=''>用户以及其他详细信息</td></tr>","<tr><td align=''>-x</td><td align=''>显示没有控制终端的进程</td></tr>","</tbody></table>","<p>Linux系统中时刻运行着许多进程，如果能够合理的管理它们，则可以优化系统的性能。在Linux系统中，有5种常见的进程状态，分别为运行、中断、不可中断、僵死于停止，其各自含义如下所示：</p>","<ul>","<li>R（运行）：进程正在运行或在运行队列中等待。</li>","<li>S（中断）：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该状态。</li>","<li>D（不可中断）：进程不想赢系统异步信号，即便用<code>kill</code>命令也不能将其中断。</li>","<li>Z（僵死）：进程已经终止，但<a title='进程描述符' href='http://guojing.me/linux-kernel-architecture/posts/process-descriptor/'>进程描述符</a>依然存在，直到父进程调用<code>wait4()</code>系统函数后将进程释放。</li>","<li>T（停止）：进程收到停止信号后停止运行。</li>","</ul>","<h4 id='top命令-0'>top命令</h4>","<p>top命令用于动态地监视进程活动与系统负载等信息，其格式为：<code>top</code>。</p>","<p>top命令相当强大，能够动态地查看系统运维状态，完全将它看作Linux中的“强化版的Windows任务管理器”。</p>","<h4 id='pidof命令-0'>pidof命令</h4>","<p>pidof命令用于查询有个指定服务进程的PID值，格式为：<code>pidof [参数] [服务名称]</code>。</p>","<h4 id='kill命令-0'>kill命令</h4>","<p>kill命令用于终止<strong>某个指定PID</strong>的服务进程，格式为：<code>kill [参数] [进程PID]</code>。</p>","<h4 id='killall命令-0'>killall命令</h4>","<p>killall命令用于终止<strong>某个指定名称</strong>的服务所对应的全部进程，格式为：<code>killall [参数] [进程名称]</code>。</p>","<h3 id='2.3系统状态检测命令-0'>2.3系统状态检测命令</h3>","<p>想要更快地、更好地了解Linux服务器，必须具备快速查看Linux系统运行状态的能力。</p>","<h4 id='ifconfig命令-0'>ifconfig命令</h4>","<p>ifconfig命令用于获取网卡配置与网络状态等信息，格式为：<code>ifconfig [网络设备] [参数]</code>。</p>","<p>主要使用该命令查看网卡名称、inet后面的IP地址、ether参数后面的网卡物理地址（又称为MAC地址）。</p>","<h4 id='uname命令-0'>uname命令</h4>","<p>uname命令用于查看系统内核与系统版本等信息，格式为：<code>uname [-a | -n]</code>。</p>","<p>一般会固定搭配上<code>-a</code>参数<strong>来完整地查看</strong>当前系统的内核名称、主机名、内核发行版本、节点名、系统时间、硬件名称、硬件平台、处理器类型以及操作系统名称等信息。或直接使用<code>-n</code>参数<strong>只查看当前系统主机名</strong>。</p>","<h4 id='uptime命令-0'>uptime命令</h4>","<p>uptime用于查看系统的<strong>负载信息</strong>，格式为：<code>uptime</code>。</p>","<p>该条指令的输出格式为：<code>系统时间 系统已运行时间 连接数 1、5、15分钟内的系统平均负载</code>。就像这样：</p>","<pre>","<code>20:41:02 up 39 m<span class='hl-keyword'>in</span>,  1 user,  load average: 0.38, 1.43, 1.17</code>","</pre>","<p>负载值越低越好，尽量不要长期超过1，在生产环境中不要超过5。</p>","<blockquote>","<p><strong>负载值</strong>的计算：</p>","<p>负载值为运行队列中的平均进程数</p>","</blockquote>","<h4 id='free命令-0'>free命令</h4>","<p>free用于显示当前系统中内存的使用量信息，格式为：<code>free [-h]</code>。</p>","<h4 id='who命令-0'>who命令</h4>","<p>who用于查看当前登入主机的用户终端信息，格式为：<code>who [参数]</code>。</p>","<h4 id='last命令-0'>last命令</h4>","<p>last命令用于产看所有系统的登陆记录，格式为：<code>last[参数]</code>。</p>","<p>注意：这些信息都是以日志文件的形式保存在系统中，因此黑客可以很容易地对内容进行<strong>篡改</strong>。</p>","<h4 id='history命令-0'>history命令</h4>","<p>history命令用于显示历史执行过的命令，格式为：<code>history [-c]</code>。</p>","<p>这条指令默认输出执行过的最近1000条命令记录，可自定义<code>/etc/profile</code>文件中的<code>HISTSIZE</code>变量值。如果使用<code>-c</code>参数则会清空所有的命令历史记录。</p>","<p>使用history命令显示的历史指令前会有数字标号，我们可以使用<code>!数字标号</code>的格式来重复执行某条指令。</p>","<h4 id='sosreport命令-0'>sosreport命令</h4>","<p>sosreport命令用于收集系统配置及架构信息并输出诊断文档，格式为：<code>sosreport</code>。</p>","<p>当Linux系统出现故障需要练习技术支持人员时，大多数时候都要先使用这个命令来简单收集系统的运行状态服务配置信息，以便让维修人员进行修理。</p>","<h3 id='2.4工作目录切换命令-0'>2.4工作目录切换命令</h3>","<p>工作目录指的是用户当前在系统中所处的位置。</p>","<h4 id='pwd命令-0'>pwd命令</h4>","<p>pwd命令用于显示用户当前在系统中所处的工作目录，格式为：<code>pwd [选项]</code>。</p>","<h4 id='cd命令-0'>cd命令</h4>","<p>cd命令用于切换工作路径，格式为：<code>cd [目录名称]</code>。</p>","<p>可以通过<code>cd -</code>命令返回到上一次所处的目录，使用<code>cd ~</code>命令切换到当前用户的家目录。</p>","<h4 id='ls命令-0'>ls命令</h4>","<p>ls命令用于显示目录中的文件信息，格式为：<code>ls [选项] [文件]</code>。</p>","<table>","<thead><tr><th>参数</th><th>作用</th></tr></thead>","<tbody>","<tr><td align=''>-a</td><td align=''>看到全部文件（包括隐藏文件）</td></tr>","<tr><td align=''>-l</td><td align=''>查看文件的属性、大小等详细信息</td></tr>","<tr><td align=''>-d</td><td align=''>查看目录属性信息</td></tr>","</tbody></table>","<h3 id='2.5文本文件编辑命令-0'>2.5文本文件编辑命令</h3>","<p>在Linux系统中，<strong>一切都是文件</strong>。</p>","<p>所以对服务长须进行配置自然也就是编辑程序的配置文件。</p>","<h4 id='cat命令-0'>cat命令</h4>","<p>cat命令用于查看纯文本文件（内容较少的），格式为<code>cat [选项] [文件]</code>。</p>","<p>真羡慕有猫的人。</p>","<table>","<thead><tr><th>参数</th><th>作用</th></tr></thead>","<tbody>","<tr><td align=''>-n</td><td align=''>显示行号</td></tr>","</tbody></table>","<h4 id='more命令-0'>more命令</h4>","<p>more命令用于查看纯文本文件（内容较多的），格式为：<code>more [选项] [文件]</code>。</p>","<p>more命令会在最下面使用百分比的形式来提示您已经阅读了多少内容，同时还可使用空格键或回车键向下翻页。</p>","<h4 id='head命令-0'>head命令</h4>","<p>head命令用于查看纯文本文档的前N行，格式为：<code>head [选项] [文件]</code>。</p>","<h4 id='tail命令-0'>tail命令</h4>","<p>tail命令用于查看纯文本文档的后N行或者持续刷新内容，格式为：<code>tail [选项] [文件]</code>。</p>","<table>","<thead><tr><th>参数</th><th>作用</th></tr></thead>","<tbody>","<tr><td align=''>-n</td><td align=''>指定查看的行数</td></tr>","<tr><td align=''>-f</td><td align=''>持续刷新</td></tr>","</tbody></table>","<h4 id='tr命令-0'>tr命令</h4>","<p>tr命令用于替换文本文件中的字符，格式为：<code>tr [选项] [原始字符] [目标字符]</code>。</p>","<p>常用的字符范围如下表：</p>","<table>","<thead><tr><th>简易正则</th><th>字符范围</th></tr></thead>","<tbody>","<tr><td align=''>[a-z]</td><td align=''>小写字符组成的字符串</td></tr>","<tr><td align=''>[A-Z]</td><td align=''>大写字符组成的字符串</td></tr>","<tr><td align=''>[0-9]</td><td align=''>数字串</td></tr>","<tr><td align=''>[x*n]</td><td align=''>字符x重复出现n次</td></tr>","</tbody></table>","<p>了解一下参数：</p>","<table>","<thead><tr><th>参数</th><th>作用</th></tr></thead>","<tbody>","<tr><td align=''>-c</td><td align=''>用原始字符的补集替换此字符集（一头雾水.png）</td></tr>","<tr><td align=''>-d</td><td align=''>删除原始字符中的所有输入字符</td></tr>","<tr><td align=''>-s</td><td align=''>删除所有重复出现字符序列，只保留第一个（一头雾水.png）</td></tr>","</tbody></table>","<h4 id='wc命令-0'>wc命令</h4>","<p>wc命令用于统计文本指定文本的行数、字数、字节数，格式为：<code>wc [参数] 文本（文件）</code>。</p>","<table>","<thead><tr><th>参数</th><th>作用</th></tr></thead>","<tbody>","<tr><td align=''>-l</td><td align=''>只显示行数</td></tr>","<tr><td align=''>-w</td><td align=''>只显示单词数</td></tr>","<tr><td align=''>-c</td><td align=''>只显示字节数</td></tr>","</tbody></table>","<h4 id='stat命令-0'>stat命令</h4>","<p>stat命令用于查看文件的具体存储信息和时间信息，格式为：<code>stat 文件名称</code>。</p>","<p><span id='file_time_types'></span></p>","<p>文件的三种时间状态为：<strong>Access</strong>、<strong>Modify</strong>、<strong>Change</strong>，分别对应着<strong>访问时间</strong>、<strong>修改时间</strong>、<strong>状态变动时间</strong>。</p>","<blockquote>","<p><strong>访问时间</strong>：读一次这个文件的内容，这个时间就会更新。但是需要注意的是，<code>ls</code>、<code>stat</code>命令不会修改文件的访问时间。</p>","<p><strong>修改时间</strong>：修改时间是文件内容最后一次被修改的时间。比如：<code>vi</code>后保存文件，<code>ls -l</code>列出的时间就是这个时间。</p>","<p><strong>状态改动时间</strong>：是该文件的<a title='i节点' href='https://www.cnblogs.com/Cccarl/p/6994372.html#topics'>i节点</a>最后一次被修改的时间，通过<code>chmod</code>、<code>chown</code>命令修改一次文件属性，这个时间就会更新。</p>","</blockquote>","<h4 id='cut命令-0'>cut命令</h4>","<p>cut命令用于按<strong>列</strong>提取文本字符，格式为：<code>cut [参数] 文本</code>。</p>","<p>常用的参数为：</p>","<table>","<thead><tr><th>参数</th><th>作用</th></tr></thead>","<tbody>","<tr><td align='center'>-f</td><td align='center'>需要看的列数，如<code>-f1</code>：第一列</td></tr>","<tr><td align='center'>-d</td><td align='center'>设置间隔符号，如<code>-d:</code>：以冒号（：）为间隔</td></tr>","</tbody></table>","<h4 id='diff命令-0'>diff命令</h4>","<p>diff命令用于比较多个文本文件的差异，格式为：<code>diff [参数] 文件</code>。</p>","<p>常用的参数为：</p>","<table>","<thead><tr><th>参数</th><th>作用</th></tr></thead>","<tbody>","<tr><td align=''>--brief</td><td align=''>显示比较后的结果，判断文件是否相同</td></tr>","<tr><td align=''>-c</td><td align=''>描述文件内容的具体不同</td></tr>","</tbody></table>","<h3 id='2.6文件目录管理命令-0'>2.6文件目录管理命令</h3>","<p>在Linux系统的日常运维工作中，还需要掌握对文件的创建、修改、赋值、剪切、更名与删除等操作。</p>","<h4 id='touch命令-0'>touch命令</h4>","<p>touch命令用于创建空白文件或者设置文件的时间，格式为：<code>touch [选项] [文件]</code>。</p>","<p>常用的参数如下：</p>","<p>关于文件不同类型时间的介绍，<a title='点击这里' href='#file_time_types'>点击这里</a>。</p>","<table>","<thead><tr><th>参数</th><th>作用</th></tr></thead>","<tbody>","<tr><td align=''>-a</td><td align=''>仅修改<strong>读取时间</strong></td></tr>","<tr><td align=''>-m</td><td align=''>仅修改<strong>修改时间</strong></td></tr>","<tr><td align=''>-d</td><td align=''>同时修改<code>atime</code>与<code>mtime</code></td></tr>","</tbody></table>","<h4 id='mkdir命令-0'>mkdir命令</h4>","<p>mkdir命令用于创建空白的目录，格式为：<code>mkdir [选项] 目录</code>。</p>","<p>除了能创建单个空白目录外，mkdir命令还可以结合<code>-p</code>参数来递归创建出具有<strong>嵌套层叠</strong>关系的文件目录。</p>","<h4 id='cp命令-0'>cp命令</h4>","<p>cp命令用复制文件或者目录，格式为：<code>cp [选项] 源文件 目标文件</code>。</p>","<p>复制操作具体分为三种情况：</p>","<ul>","<li>如果目标文件是目录，则会把源文件复制到该目录中。</li>","<li>如果目标文件也是普通文件，则会询问是否要覆盖它。</li>","<li>如果目标文件不存在，则执行正常的复制操作。</li>","</ul>","<p>常用的参数如下：</p>","<table>","<thead><tr><th>参数</th><th>作用</th></tr></thead>","<tbody>","<tr><td align=''>-p</td><td align=''>保留原始文件的属性</td></tr>","<tr><td align=''>-d</td><td align=''>若对象为<strong>链接</strong>文件，则保留该链接文件的属性</td></tr>","<tr><td align=''>-r</td><td align=''>递归持续复制（用于目录）</td></tr>","<tr><td align=''>-i</td><td align=''>若目标文件存在则询问是否覆盖</td></tr>","<tr><td align=''>-a</td><td align=''>相当于-pdr</td></tr>","</tbody></table>","<h4 id='mv命令-0'>mv命令</h4>","<p>mv命令用于剪切文件或将文件重命名，格式为：<code>mv [选项] 源文件 [目标文件|目标文件名]</code>。</p>","<p>在同一个目录中对一个文件进行剪切操作，其实就是对其进行重命名。</p>","<h4 id='rm命令-0'>rm命令</h4>","<p>rm命令用于删除文件或目录，格式为：<code>rm [选项] 文件</code>。</p>","<p>常用的参数为：</p>","<table>","<thead><tr><th>参数</th><th>作用</th></tr></thead>","<tbody>","<tr><td align='center'>-f</td><td align='center'>强制删除，跳过确认信息</td></tr>","<tr><td align='center'>-r</td><td align='center'>删除一个目录</td></tr>","<tr><td align='center'>-i</td><td align='center'>提示信息确定用户是否真的删除</td></tr>","</tbody></table>","<h4 id='dd命令-0'>dd命令</h4>","<p>dd命令用于指定大小和个数的<strong>数据块</strong>来复制文件或转换文件，格式为：<code>dd [参数]</code>。</p>","<p>常用的参数如下：</p>","<table>","<thead><tr><th>参数</th><th>作用</th></tr></thead>","<tbody>","<tr><td align=''>if</td><td align=''>输入的文件名称</td></tr>","<tr><td align=''>of</td><td align=''>输出的文件名称</td></tr>","<tr><td align=''>bs</td><td align=''>设置每个块的<strong>大小</strong></td></tr>","<tr><td align=''>count</td><td align=''>设置要复制的块的<strong>个数</strong></td></tr>","</tbody></table>","<blockquote>","<p>Example</p>","<p>从<code>/dev/zero</code>设备文件中取出一个大小为560MB的数据块，保存成名为560_file的文件：</p>","<p><code>dd if=/dev/zero of=560_file count=1 bs=560M</code></p>","<p><code>/dev/zero</code>这个文件不会占用系统存储空间，但却可以提供无穷无尽的数据。（大雾）</p>","</blockquote>","<h4 id='file命令-0'>file命令</h4>","<p>file命令用于查看文件的<strong>类型</strong>，类似于Windows下面的文件后缀名，格式为：<code>file 文件名</code>。</p>","<h3 id='2.7打包压缩与搜索命令-0'>2.7打包压缩与搜索命令</h3>","<p>在使用Windows的时候，我就已经很青睐于那些绿色免安装版软件，一是它安全，二是它不会胡乱修改我的系统注册表。</p>","<p>下面来学习一下如何在Linux中打包压缩文件。</p>","<h4 id='tar命令-0'>tar命令</h4>","<p>tar命令用于对文件进行打包压缩或解压，格式为：<code>tar [选项] [文件]</code>。</p>","<p>tar命令常用的参数如下：</p>","<table>","<thead><tr><th>参数</th><th>作用</th></tr></thead>","<tbody>","<tr><td align=''>-c</td><td align=''>创建压缩文件</td></tr>","<tr><td align=''>-x</td><td align=''>解压压缩文件</td></tr>","<tr><td align=''>-t</td><td align=''>查看压缩包中有哪些文件</td></tr>","<tr><td align=''>-z</td><td align=''>用Gzip压缩或解压</td></tr>","<tr><td align=''>-j</td><td align=''>用bzip2压缩或解压</td></tr>","<tr><td align=''>-v</td><td align=''>显示压缩或解压的过程</td></tr>","<tr><td align=''>-f</td><td align=''>目标文件名</td></tr>","<tr><td align=''>-P</td><td align=''>保留原始的权限与属性</td></tr>","<tr><td align=''>-p</td><td align=''>使用绝对路径来压缩</td></tr>","<tr><td align=''>-C</td><td align=''>指定解压到的目录</td></tr>","</tbody></table>","<blockquote>","<p>Example</p>","<p>将<code>/etc</code>目录，通过Gzip格式进行压缩，并把文件命名为etc.tar.gz</p>","<p><code>tar -czvf etc.tar.gz /etc</code></p>","</blockquote>","<h4 id='grep命令-0'>grep命令</h4>","<p>grep命令用于在文本中执行关键词搜索，并显示匹配的结果，格式为：<code>grep [选项] [文件]</code>。</p>","<p>常用的参数如下所示：</p>","<table>","<thead><tr><th>参数</th><th>作用</th></tr></thead>","<tbody>","<tr><td align=''>-b</td><td align=''>将可执行文件当作文本文件来搜索</td></tr>","<tr><td align=''>-c</td><td align=''>仅显示找到的行数</td></tr>","<tr><td align=''>-i</td><td align=''>忽略大小写</td></tr>","<tr><td align=''>-n</td><td align=''>显示行号</td></tr>","<tr><td align=''>-v</td><td align=''>反向选择——仅列出<strong>没有关键词的行</strong></td></tr>","</tbody></table>","<p>当然，grep命令还有其它妙用，比如搭配管道命令符使用，来<a title='看个实例' href='#grep_used'>看个实例</a>。</p>","<h4 id='find命令-0'>find命令</h4>","<p>find命令用于按照指定条件来查找文件，格式为：<code>find [查找路径] 寻找条件 操作 </code> 。</p>","<p><strong>Linux系统中的一切都是文件</strong>。</p>","<p>由于参数过多，就不在这里一一列出，在需要使用的时候可以直接<code>man find</code>。</p>","<h3 id='2.8其它常用命令-0'>2.8其它常用命令</h3>","<h4 id='ping命令-0'>ping命令</h4>","<p>ping命令来测试与某一主机的连通性，格式为：<code>ping xxx.xxx.xxx.xxx</code>。</p>","<p>常用的参数如下：</p>","<table>","<thead><tr><th>参数</th><th>作用</th></tr></thead>","<tbody>","<tr><td align=''>-c</td><td align=''>规定尝试的次数</td></tr>","<tr><td align=''>-i</td><td align=''>定义每个数据包的发送间隔</td></tr>","<tr><td align=''>-W</td><td align=''>定义等待超时时间</td></tr>","</tbody></table>","<h4 id='read命令-0'>read命令</h4>","<p>read命令接收标准输入——即键盘的输入，或者其它文件描述符的输入，并将输入存在一个标准变量中。格式为：<code>read -p 'message' varible</code>。</p>","<p>常用的参数如下：</p>","<table>","<thead><tr><th>参数</th><th>作用</th></tr></thead>","<tbody>","<tr><td align=''>-p</td><td align=''>输出提示语句</td></tr>","<tr><td align=''>-n</td><td align=''>最大接收参数个数</td></tr>","<tr><td align=''>-t</td><td align=''>最大等待用户输入秒数</td></tr>","<tr><td align=''>-s</td><td align=''>用户输入不显示在监视器上</td></tr>","</tbody></table>","<h4 id='su命令-0'>su命令</h4>","<p>su命令用于切换当前操作用户，如果当前用户不是超级用户，则需要输入使用者的密码。格式为：<code>su - username</code>。</p>","<p>常用的参数如下：</p>","<table>","<thead><tr><th>参数</th><th>作用</th></tr></thead>","<tbody>","<tr><td align=''>-f</td><td align=''>不必读取启动文件</td></tr>","<tr><td align=''>-l</td><td align=''>相当于重新以<code>username</code>进行登陆，切换了大部分的环境变量，工作目录也会改变</td></tr>","<tr><td align=''>-c</td><td align=''>执行指令后再变回原来的用户，该参数后接Linux指令</td></tr>","</tbody></table>","<blockquote>","<p><code>su</code>与<code>su -</code>的区别： </p>","<ul>","<li><code>su</code>是切换到其他用户，但是不切换环境变量</li>","<li><code>su -</code>是完整的切换到一个用户环境</li>","</ul>","<p>因此，在大部分情况下，请使用<code>su - username</code>，否则可能会出现某些<strong>命令因为环境变量的问题而执行不了</strong>的情况。</p>","<p><code>su</code>与<code>sudo</code>的区别：</p>","<p>通过<code>su - root</code>获得超级管理员的权限之后，就会出现由于权限过大而管理混乱的情况。因此，<code>sudo</code>的好处就是：把某些超级权限有针对性的下放，并且不需要普通用户知道<code>root</code>的密码。这是一种受限制的<code>su</code>，显然<strong>更加安全</strong>。</p>","<p><code>sudo</code>需要配置<code>/etc/sudoers</code>来进行授权。</p>","</blockquote>","<h4 id='fdisk命令-0'>fdisk命令</h4>","<p>fdisk命令用于管理磁盘分区，格式为：<code>fdisk [交互以外的参数] [磁盘名称]</code>。</p>","<p>与前面讲述的命令参数不同，这条命令的某些<strong>参数是交互的</strong>，可以根据需求动态调整。</p>","<p>常用的<strong>交互参数</strong>如下：</p>","<table>","<thead><tr><th>参数</th><th>作用</th></tr></thead>","<tbody>","<tr><td align=''>m</td><td align=''>查看全部可用参数</td></tr>","<tr><td align=''>n</td><td align=''>添加新的分区</td></tr>","<tr><td align=''>d</td><td align=''>删除某个分区信息</td></tr>","<tr><td align=''>l</td><td align=''>列出所有可用的分区类型</td></tr>","<tr><td align=''>t</td><td align=''>改变某个分区的类型</td></tr>","<tr><td align=''>p</td><td align=''>查看分区信息</td></tr>","<tr><td align=''>w</td><td align=''>保存并退出</td></tr>","<tr><td align=''>q</td><td align=''>不保存直接退出</td></tr>","</tbody></table>","<h4 id='df命令-0'>df命令</h4>","<p>df命令用于统计磁盘空间或文件系统的使用情况。格式为：<code>df</code>。</p>","<h2 id='3.管道符、重定向与环境变量-0'>3.管道符、重定向与环境变量</h2>","<p>注意了注意了，本章所提及知识点的应用范围非常广。</p>","<h3 id='3.1输入输出重定向-0'>3.1输入输出重定向</h3>","<p>简而言之，<strong>输入重定向是指把文件导入到命令中</strong>，而<strong>输出重定向则是把原本要输出到屏幕的信息写到指定文件中</strong>。</p>","<p>对重定向的默认方式为以下三种：<span id='file_desc'></span></p>","<ul>","<li>标准输入重定向<code>STDIN，文件描述符为0</code>：默认从键盘输入，也可从其它文件或命令中输入。</li>","<li>标准输出重定向<code>STDOUT，文件描述符为1</code>：默认输出到屏幕。</li>","<li>错误输出重定向<code>STDERR，文件描述符为2</code>：默认输出到屏幕。</li>","</ul>","<h4 id='输入重定向-0'>输入重定向</h4>","<p>下表为输入重定向时会用到的符号及其作用：</p>","<blockquote>","<p>注意，在符号的两边各存在着一个<strong>空格</strong>。</p>","</blockquote>","<table>","<thead><tr><th>符号</th><th>作用</th></tr></thead>","<tbody>","<tr><td align=''>命令 <code>&lt;</code> 文件</td><td align=''>将文件作为命令的标准输入</td></tr>","<tr><td align=''>命令 <code>&lt;&lt;</code> 分界符</td><td align=''>从标准输入中读入，直到遇见分界符才停止</td></tr>","<tr><td align=''>命令 <code>&lt;</code> 文件1 <code>&lt;</code> 文件2</td><td align=''>将文件1作为命令的标准输入，并将标准输出到文件2</td></tr>","</tbody></table>","<h4 id='输出重定向-0'>输出重定向</h4>","<p>下表为输出重定向时会用到的符号及其作用：</p>","<blockquote>","<p>注意，在符号的两边各存在着一个<strong>空格</strong>。</p>","</blockquote>","<table>","<thead><tr><th>符号</th><th>作用</th></tr></thead>","<tbody>","<tr><td align=''>命令 <code>&gt;</code> 文件</td><td align=''>将标准输出重定向到一个文件中（清空原有文件的数据）</td></tr>","<tr><td align=''>命令 <code>2&gt;</code> 文件</td><td align=''>将错误输出重定向到一个文件中（清空原有文件的数据）</td></tr>","<tr><td align=''>命令 <code>&gt;&gt;</code> 文件</td><td align=''>将标准输出重定向到一个文件中（追加到原有内容的后面）</td></tr>","<tr><td align=''>命令 <code>2&gt;&gt;</code> 文件</td><td align=''>将错误输出重定向到一个文件中（追加到原有内容的后面）</td></tr>","<tr><td align=''>命令 <code>&gt;&gt;</code> 文件 <code>2&gt;&1</code><br />或<br />命令 <code>&&gt;&gt;</code> 文件</td><td align=''>将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）</td></tr>","</tbody></table>","<p>对于重定向中的标准输出模式，可以省略<a title='文件描述符' href='#file_desc'>文件描述符</a>1不写，而<strong>错误输出模式</strong>的文件描述符<code>2</code>是必须要写的。</p>","<blockquote>","<p>Example</p>","<p>通过标准输出重定向将<code>man bash</code>命令原本要输出到屏幕的信息写入到文件<code>show.txt</code>中。</p>","<p><code>man bash &gt; show.txt</code> </p>","<p>Example</p>","<p>把用户执行<code>shell</code>脚本过程中命令的报错写入到文件<code>error.txt</code>中。</p>","<p><code>xxxxx 2&gt; error.txt </code></p>","</blockquote>","<h3 id='3.2管道命令符-0'>3.2管道命令符</h3>","<p>一言以蔽之，管道命令符的作用为：<strong>把前一个命令原本要输出到屏幕的数据当作是后一个命令的标准输入</strong>。</p>","<p>管道命令符在一个命令中可以使用多次，因此我们完全可以以这种形式来使用它：</p>","<p><code>命令A | 命令B | 命令C</code></p>","<h3 id='3.3命令行的通配符-0'>3.3命令行的通配符</h3>","<p>就像正则表达式一样，我们可以在命令行中使用通配符来避免忘记某个文件具体名称的情况。</p>","<p>就像<code>name*</code> 、<code>name?</code>、<code>name[0-9]</code>、<code>name[123]</code>这种。</p>","<p>关于Linux中的正则表达式，我将会专门写一篇文章来介绍。</p>","<h3 id='3.4常见且有用的转义字符-0'>3.4常见且有用的转义字符</h3>","<p>为了能够更好的理解用户的表达，Shell解释器还提供了特别丰富的转义字符还处理输入的特殊数据。</p>","<p>最常用的4个转义字符如下：</p>","<ul>","<li>反斜杠<code>\\</code>：使反斜杠后面的一个变量变为单纯的字符串。</li>","<li>单引号<code>''</code>：转义其中所有的变量为单纯的字符串。</li>","<li>双引号 <code>\"\"</code>：保留其中的变量属性，不进行转义处理。</li>","<li>反引号<code> </code> `：把其中的命令执行后返回结果。</li>","</ul>","<h3 id='3.5重要的环境变量-0'>3.5重要的环境变量</h3>","<p>Linux作为一个多用户多任务的操作系统，能够为每个用户提供独立的、合适的工作运行环境。</p>","<p>因而在一个用户环境下设置的变量的作用域只在当前用户下有效，如果出于工作需要，可以使用<code>export</code>命令将其提升为全局变量，这样其它用户也就可以使用它了。</p>","<blockquote>","<p>Example</p>","<p><code>export WORKDIR</code></p>","</blockquote>","<p>下是一些Linux中重要的环境变量：</p>","<table>","<thead><tr><th>变量名称</th><th>作用</th></tr></thead>","<tbody>","<tr><td align=''>HOME</td><td align=''>用户的主目录（即家目录）</td></tr>","<tr><td align=''>SHELL</td><td align=''>用户在使用的Shell解释器名称</td></tr>","<tr><td align=''>HISTSIZE</td><td align=''>输出的历史命令记录条数</td></tr>","<tr><td align=''>MAIL</td><td align=''>邮件保存路径</td></tr>","<tr><td align=''>RANDOM</td><td align=''>生成一个随机数字</td></tr>","</tbody></table>","<h2 id='4.Vim编辑器与Shell命令脚本-0'>4.Vim编辑器与Shell命令脚本</h2>","<p>Vim编辑器就相当于Windows下面的notepad，只不过Vim提供的众多命令使得文本的编辑更加便捷；Shell命令脚本就相当于Windows下面的bash脚本，它提供了集成Linux命令的能力，使得自动化工作的实现成为可能。</p>","<h3 id='4.1Vim编辑器-0'>4.1Vim编辑器</h3>","<p>Vim编辑器中设置了三种模式——命令模式、末行模式和编辑模式，每种模式分别又支持多种不同的命令快捷键，这大大提高了工作效率。</p>","<ul>","<li><strong>命令模式</strong>：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作</li>","<li><strong>输入模式</strong>：正常的文本输入</li>","<li><strong>末行模式</strong>：保存或退出文档，以及设置编辑环境</li>","</ul>","<p>这三种模式之间的转换如下所示：</p>","<p><img alt='vim 模式转换' title='vim 模式转换' src='https://i.loli.net/2020/01/02/bNEOmpGwPMXeFk1.png' ></p>","<p><strong>命令模式</strong>中常用的命令如下表：</p>","<table>","<thead><tr><th>命令</th><th>作用</th></tr></thead>","<tbody>","<tr><td align=''>dd</td><td align=''>删除（剪切）光标所在整行</td></tr>","<tr><td align=''>5dd</td><td align=''>删除（剪切）从光标处开始的5行</td></tr>","<tr><td align=''>yy</td><td align=''>复制光标所在整行</td></tr>","<tr><td align=''>5yy</td><td align=''>复制从光标处开始的5行</td></tr>","<tr><td align=''>n</td><td align=''>显示搜索命令定位到的下一个字符串</td></tr>","<tr><td align=''>N</td><td align=''>显示搜索命令定位到的上一个字符串</td></tr>","<tr><td align=''>u</td><td align=''>撤销上一步的操作</td></tr>","<tr><td align=''>p</td><td align=''>将之前删除（dd）或复制（yy）过的数据粘贴到光标后面</td></tr>","</tbody></table>","<p>末行模式用于保存或退出文件，以及设置Vim编辑器的工作环境。</p>","<p><strong>末行模式</strong>中可用的命令如下表所示：</p>","<table>","<thead><tr><th>命令</th><th>作用</th></tr></thead>","<tbody>","<tr><td align=''><code>:w</code></td><td align=''>保存</td></tr>","<tr><td align=''><code>:q</code></td><td align=''>退出</td></tr>","<tr><td align=''><code>:q!</code></td><td align=''>强制退出</td></tr>","<tr><td align=''><code>:wq!</code></td><td align=''>强制保存退出</td></tr>","<tr><td align=''><code>:set nu</code></td><td align=''>显示行号</td></tr>","<tr><td align=''><code>:set nonu</code></td><td align=''>不显示行号</td></tr>","<tr><td align=''><code>:命令</code></td><td align=''>执行该命令</td></tr>","<tr><td align=''><code>:整数</code></td><td align=''>跳转到该行</td></tr>","<tr><td align=''><code>:s/one/two</code></td><td align=''>将当前光标所在行的<strong>第一个</strong>one替换成two</td></tr>","<tr><td align=''><code>:s/one/two/g</code></td><td align=''>将当前光标所在行的所有one替换成two</td></tr>","<tr><td align=''><code>:%s/one/two/g</code></td><td align=''>将全文中的所有one替换成two</td></tr>","<tr><td align=''><code>?字符串</code></td><td align=''>在文本中从下至上搜索该字符串</td></tr>","<tr><td align=''><code>/字符串</code></td><td align=''>在文本中从上至下搜索该字符串</td></tr>","</tbody></table>","<h4 id='练习：配置主机名称、hostname命令-0'>练习：配置主机名称、hostname命令</h4>","<p>为了便于在局域网中查找某台特定的主机，更便于区分。除了要有IP地址以外，一个主机名也是十分重要的。</p>","<p>在Linux系统中，主机名大多保存在<code>/ect/hostname</code>文件中。</p>","<p>修改这个文件需要<code>Root</code>权限。</p>","<p>使用<code>hostname</code>命令查看当前的主机名称，有时主机名称的修改不会立刻同步到系统中，或许需要重启虚拟机。</p>","<h3 id='4.2编写Shell脚本-0'>4.2编写Shell脚本</h3>","<p>Shell脚本文件的名称可以任意取，但是为了避免被误认为是普通文件，建议将<code>.sh</code>后缀加上，以表示这是一个脚本文件。</p>","<p>一个Shell脚本文件就像是这样：</p>","<pre>","<code>#!/b<span class='hl-keyword'>in</span>/bash</code>","<code>#For Example The Shell IS</code>","<code>pwd</code>","<code>ls -al</code>","</pre>","<p>在上面这个脚本中，出现了三种不同的元素：</p>","<ul>","<li><strong>脚本声明</strong>：<code>#!</code>用来告诉系统使用哪种Shell解释器来执行该脚本</li>","<li><strong>注释信息</strong>：<code>#</code>是对脚本功能和某些命令的介绍信息</li>","<li><strong>可执行语句</strong>：就是我们平常执行的Linux命令</li>","</ul>","<h3 id='4.3Shell脚本的执行-0'>4.3Shell脚本的执行</h3>","<p>你可以使用bash解释器命令直接运行Shell脚本，就像这样：</p>","<pre>","<code>bash example.sh</code>","</pre>","<code>也可以通过输入完整路径的方式来执行，但默认会提示权限不足，这里的权限指的是文件的读、写、执行权限。</code>","<code>这时只需要为脚本文件增加执行权限即可。</code>","<code>就像这样：</code>","<pre>","<h1 id='./example.sh-0'>./example.sh</h1>","<code>bash: ./Example.sh: Permission denied</code>","<h1 id='chmod u+x example.sh-0'>chmod u+x example.sh</h1>","<h1 id='./example.sh-1'>./example.sh</h1>","</pre>","<h3 id='4.4高级Shell脚本-0'>4.4高级Shell脚本</h3>","<h4 id='接收用户输入的参数-0'>接收用户输入的参数</h4>","<p>我们当然不满足于执行一些预先定义的脚本。要实现按照用户的意愿执行命令，接收输入的参数是必须的。</p>","<p>常用的功能变量如下：</p>","<table>","<thead><tr><th>变量</th><th>作用</th></tr></thead>","<tbody>","<tr><td align=''>$0</td><td align=''>当前Shell脚本的名称</td></tr>","<tr><td align=''>$#</td><td align=''>总共有几个参数</td></tr>","<tr><td align=''>$*</td><td align=''>对应所有位置的参数</td></tr>","<tr><td align=''>$?</td><td align=''>上一次命令的执行返回值</td></tr>","<tr><td align=''>$1、$2、 $n</td><td align=''>对应第n个位置的参数值</td></tr>","</tbody></table>","<p>常见的使用方法如下所示：</p>","<blockquote>","<p>Example</p>","</blockquote>","<pre>","<code>&gt;example.sh</code>","<code>#!/b<span class='hl-keyword'>in</span>/bash</code>","<code>echo \"当前脚本名称为$0\"</code>","<code>echo \"总共有$#个参数，分别是$*。\"</code>","<code>echo \"第一个参数为$1，第三个为$3。\"</code>","<h1 id='sh exapmle.sh one two three-0'>sh exapmle.sh one two three</h1>","<code>当前脚本名称为example.sh。</code>","<code>总共有3个参数，分别是one two three。</code>","<code>第一个参数是one，第三个是three。</code>","</pre>","<h4 id='判断用户输入的参数-0'>判断用户输入的参数</h4>","<p>Shell脚本中的<strong>条件测试语法</strong>可以判断表达式是否成立，<strong>若条件成立则返回数字0，否则便返回其它随机数</strong>。条件测试语法格式如下：</p>","<blockquote>","<p>注意：条件表达式两边应均有一个空格。</p>","</blockquote>","<p><code>测试语句格式: [ 条件表达式 ]</code></p>","<p>条件测试语句可以按照测试对象划分为4种：</p>","<ul>","<li>文件测试</li>","<li>数值比较</li>","<li>字符串比较</li>","</ul>","<h5 id='文件测试-0'>文件测试</h5>","<p>常用的文件测试运算符如下：</p>","<table>","<thead><tr><th>运算符</th><th>作用</th></tr></thead>","<tbody>","<tr><td align=''>-d</td><td align=''>测试文件是否为目录</td></tr>","<tr><td align=''>-e</td><td align=''>测试文件是否存在</td></tr>","<tr><td align=''>-f</td><td align=''>判断是否为一般文件</td></tr>","<tr><td align=''>-r</td><td align=''>测试当前用户是否有权限读取</td></tr>","<tr><td align=''>-w</td><td align=''>测试当前用户是否有权限写入</td></tr>","<tr><td align=''>-x</td><td align=''>测试当前用户是否有权限执行</td></tr>","</tbody></table>","<p>当然，你还可以在测试语句中使用逻辑语句<code>&&</code>、<code>||</code>、<code>!</code>。</p>","<ul>","<li><code>&&</code>代表当前面的命令<strong>执行成功后</strong>才会执行它后面的命令</li>","<li><code>||</code>代表当前面的命令<strong>执行失败后</strong>才会执行它后面的命令</li>","<li><code>!</code>代表把测试结果取反</li>","</ul>","<h5 id='数值比较-0'>数值比较</h5>","<p>数值比较不能想当然的使用我们习以为常的大于号、小于号、等号。因为小于号<code>&lt;</code>、大于号<code>&gt;</code>分别与输入、输出重定向冲突，而等号<code>=</code>又与赋值运算符冲突。</p>","<p>一定要使用规范的整数比较运算符来进行操作。</p>","<p>常用的数值比较运算符如下：</p>","<table>","<thead><tr><th>运算符</th><th>作用</th></tr></thead>","<tbody>","<tr><td align=''>-eq</td><td align=''>是否相等</td></tr>","<tr><td align=''>-ne</td><td align=''>是否不等</td></tr>","<tr><td align=''>-gt</td><td align=''>是否大于</td></tr>","<tr><td align=''>-lt</td><td align=''>是否小于</td></tr>","<tr><td align=''>-le</td><td align=''>是否等于或小于</td></tr>","<tr><td align=''>-ge</td><td align=''>是否大于或等于</td></tr>","</tbody></table>","<h5 id='字符串比较-0'>字符串比较</h5>","<p>常用的字符串比较运算符如下：</p>","<table>","<thead><tr><th>运算符</th><th>作用</th></tr></thead>","<tbody>","<tr><td align=''>=</td><td align=''>比较字符串内容是否相同</td></tr>","<tr><td align=''>!=</td><td align=''>比较字符串内容是否不同</td></tr>","<tr><td align=''>-z</td><td align=''>判断字符串内容是否为空</td></tr>","</tbody></table>","<h3 id='4.5流程控制语句-0'>4.5流程控制语句</h3>","<h4 id='if条件测试语句-0'>if条件测试语句</h4>","<p>与其他语言的书写习惯不同，Linux中的条件分支语句十分奇怪。</p>","<p>格式如下：</p>","<pre>","<code><span class='hl-keyword'>if</span> [ 条件测试 ]</code>","<code>  then 操作1</code>","<code>  <span class='hl-keyword'>else</span> 操作2</code>","<code>fi</code>","</pre>","<p>更加复杂的格式如下：</p>","<pre>","<code><span class='hl-keyword'>if</span> [ 条件测试1 ]</code>","<code>  then 操作1</code>","<code>el<span class='hl-keyword'>if</span> [ 条件测试2 ]</code>","<code>  then 操作2</code>","<code><span class='hl-keyword'>else</span></code>","<code>  操作3</code>","<code>fi</code>","</pre>","<h4 id='for条件循环语句-0'>for条件循环语句</h4>","<p>使用了我熟悉的<code>for...in</code>语法。</p>","<p>格式如下：</p>","<pre>","<code><span class='hl-keyword'>for</span> 变量名 <span class='hl-keyword'>in</span> 取值列表</code>","<code><span class='hl-keyword'>do</span></code>","<code>  各种操作</code>","<code>done</code>","</pre>","<h4 id='while条件循环语句-0'>while条件循环语句</h4>","<p>格式如下：</p>","<pre>","<code><span class='hl-keyword'>while</span> 条件测试</code>","<code><span class='hl-keyword'>do</span> </code>","<code>  各种操作</code>","<code>done</code>","</pre>","<h4 id='case条件测试语句-0'>case条件测试语句</h4>","<p>就是switch。</p>","<p>格式如下：</p>","<pre>","<code><span class='hl-keyword'>case</span> 变量值 <span class='hl-keyword'>in</span></code>","<code>条件1)</code>","<code>\t操作1</code>","<code>\t;;</code>","<code>条件2)</code>","<code>\t操作2</code>","<code>\t;;</code>","<code>*)</code>","<code>\t默认操作</code>","<code>esac</code>","</pre>","<h2 id='5.用户身份与文件权限-0'>5.用户身份与文件权限</h2>","<p>想必大家都听过删库跑路的事情。</p>","<p>但其实，比起Windows系统Linux在用户权限控制这方面显然做的更棒。</p>","<p>Linux是一个多用户、多任务的操作系统，具有很好的稳定性与安全性，文件的权限控制做的也相当棒。</p>","<p>本章将详细讲解文件的所有者、所属组以及其他人对文件的进行的读、写、执行等操作。</p>","<h3 id='5.1用户身份与能力-0'>5.1用户身份与能力</h3>","<p>在Linux系统中，我们通过用户的<code>UID</code>值来确定用户的身份，<code>UID</code>具有唯一性，用户身份大致可分为以下几种：</p>","<ul>","<li>管理员UID为 <strong>0</strong>：即<code>root</code></li>","<li>系统用户UID为 <strong>1~999</strong>：Linux默认服务程序会有独立的系统用户负责运行，避免了因服务漏洞而引发的提权行为</li>","<li>普通用户UID从 <strong>1000</strong>开始：由管理员创建的、用于日常工作的用户</li>","</ul>","<h4 id='useradd命令-0'>useradd命令</h4>","<p>useradd命令用于创建新的用户，格式为：<code>useradd [选项] 用户名</code>。</p>","<p>使用该命令创建用户账户时，默认的<strong>用户家目录</strong>会被存放在<code>/home</code>目录中，默认的<code>Shell</code>解释器为<code>/bin/bash</code>，而且默认会创建一个与该用户同名的基本用户组。</p>","<p>基本使用到的参数如下所示：</p>","<table>","<thead><tr><th>参数</th><th>作用</th></tr></thead>","<tbody>","<tr><td align=''>-d</td><td align=''>指定用户的家目录</td></tr>","<tr><td align=''>-e</td><td align=''>账户的到期时间，格式为<code>YYYY-MM-DD</code></td></tr>","<tr><td align=''>-u</td><td align=''>指定该用户的默认UID</td></tr>","<tr><td align=''>-g</td><td align=''>指定用户的基本组，该组必须已存在</td></tr>","<tr><td align=''>-G</td><td align=''>指定一个或多个扩展组</td></tr>","<tr><td align=''>-N</td><td align=''>不创建与用户同名的基本用户组</td></tr>","<tr><td align=''>-s</td><td align=''>指定该用户的默认Shell解释器</td></tr>","</tbody></table>","<p>注意，<code>/sbin/nologin</code>也是终端解释器的一员，一旦用户的解释器被设置为<code>nologin</code>，则代表该用户不能登陆到该系统中。</p>","<blockquote>","<p>Example</p>","</blockquote>","<pre>","<code>useradd -d 8888 -s /sb<span class='hl-keyword'>in</span>/nologin exampleUser</code>","</pre>","<h4 id='groupadd命令-0'>groupadd命令</h4>","<p>groupadd命令用于创建用户组，格式为：<code>groupadd [选项] 群组名</code>。</p>","<p>把几个用户添加到一个组里面，便于针对一类用户统一安排权限。</p>","<h4 id='usermod命令-0'>usermod命令</h4>","<p>usermod命令用于修改用户的属性，格式为：<code>usermod [选项] 用户名</code>。</p>","<p>正因为Linux系统中一切都是文件，所以我们可以直接修改用户参数项目。当然，使用命令来控制更加简便。usermod可以修改已经创建的用户信息，诸如用户的UID、基本/扩展用户组、默认终端等。</p>","<p>常用的参数如下所示：</p>","<table>","<thead><tr><th>参数</th><th>作用</th></tr></thead>","<tbody>","<tr><td align=''>-c</td><td align=''>填写用户账户的相关信息</td></tr>","<tr><td align=''>-d -m</td><td align=''>参数连用，重新指定用户家目录并把旧的数据转移过去</td></tr>","<tr><td align=''>-e</td><td align=''>账户的到期时间，格式为<code>YYYY-MM-DD</code></td></tr>","<tr><td align=''>-g</td><td align=''>变更所属用户组</td></tr>","<tr><td align=''>-G</td><td align=''>变更扩展用户组</td></tr>","<tr><td align=''>-L</td><td align=''>锁定用户禁止其登陆系统</td></tr>","<tr><td align=''>-U</td><td align=''>解锁用户</td></tr>","<tr><td align=''>-s</td><td align=''>变更默认终端</td></tr>","<tr><td align=''>-u</td><td align=''>修改用户的UID</td></tr>","</tbody></table>","<h4 id='passwd命令-0'>passwd命令</h4>","<p>passwd命令用于修改用户密码、过期时间、认证信息等，格式为：<code>passwd [选项] [用户名]</code>。</p>","<p>普通用户只能使用passwd命令修改自身的系统密码，而root管理员则有权限修改其他用户的密码。</p>","<p>该命令常用的参数如下所示：</p>","<table>","<thead><tr><th>参数</th><th>作用</th></tr></thead>","<tbody>","<tr><td align=''>-l</td><td align=''>锁定用户，禁止其登陆</td></tr>","<tr><td align=''>-u</td><td align=''>解除锁定，允许用户登陆</td></tr>","<tr><td align=''>--stdin</td><td align=''>允许通过<strong>标准输入</strong>修改用户密码</td></tr>","<tr><td align=''>-d</td><td align=''>使该用户可用空密码登陆系统</td></tr>","<tr><td align=''>-e</td><td align=''>强制用户在下次登陆时修改密码</td></tr>","<tr><td align=''>-S</td><td align=''>显示用户的密码是否被锁定，以及相关信息</td></tr>","</tbody></table>","<h4 id='userdel命令-0'>userdel命令</h4>","<p>userdel命令用于删除用户，格式为：<code>userdel [选项] [用户名]</code>。</p>","<p>不加参数时，该用户的家目录默认会保留下来。</p>","<p>常用的参数如下：</p>","<table>","<thead><tr><th>参数</th><th>作用</th></tr></thead>","<tbody>","<tr><td align=''>-f</td><td align=''>强制删除用户</td></tr>","<tr><td align=''>-r</td><td align=''>同时删除用户及家目录</td></tr>","</tbody></table>","<h3 id='5.2文件权限与归属-0'>5.2文件权限与归属</h3>","<p>Linux系统中的文件类型可分为以下几种：</p>","<ul>","<li><code>-</code>：普通文件</li>","<li><code>d</code>：目录文件</li>","<li><code>l</code>：链接文件</li>","<li><code>b</code>：块设备文件</li>","<li><code>c</code>：字符设备文件</li>","<li><code>p</code>：管道文件</li>","</ul>","<p>文件的权限分为三种：<strong>可读</strong>、<strong>可写</strong>、<strong>可执行</strong>。</p>","<p>当然需要注意：</p>","<ul>","<li>对<strong>普通文件</strong>：<strong>可读</strong>表示能够读取文件的实际内容，<strong>可写</strong>表示能够编辑、新增、修改、删除文件的实际内容，<strong>可执行</strong>则表示能够运行一个脚本程序</li>","<li>对<strong>目录文件</strong>：<strong>可读</strong>表示能够读取目录内的文件列表，<strong>可写</strong>表示能够在目录内新增、删除、重命名文件，<strong>可执行</strong>则表示能够进入目录</li>","</ul>","<p>文件的<strong>读</strong>、<strong>写</strong>、<strong>执行</strong>权限可以简写为<code>r</code>、<code>w</code>、<code>x</code>，亦可以分别用数字<code>4</code>、<code>2</code>、<code>1</code>来表示。</p>","<p>即：</p>","<p><img alt='文件权限' title='文件权限' src='https://i.loli.net/2020/01/02/mEK8PRALyZdnDqV.png' ></p>","<p>使用<code>ls -l</code>便可以看到一个文件的权限。</p>","<h4 id='chmod命令-0'>chmod命令</h4>","<h2 id='6.存储结构与硬盘划分-0'>6.存储结构与硬盘划分</h2>","<p>就像Windows平台下所划分的B、C、D盘一样，Linux也有着自己的文件系统层次化标准，即FHS。</p>","<h3 id='常见的目录划分-0'>常见的目录划分</h3>","<p><strong>在Linux系统中，一切的文件目录从<code>/</code>开始</strong>。</p>","<p>下表是常见的目录名称以及对应的存储内容：</p>","<table>","<thead><tr><th>目录名称</th><th>逻辑上应放置的内容</th></tr></thead>","<tbody>","<tr><td align='left'>/boot</td><td align='left'>开机所需文件：内核、开机菜单以及所需配置文件等</td></tr>","<tr><td align='left'>/dev</td><td align='left'>以文件形式存放任何设备和接口</td></tr>","<tr><td align='left'>/etc</td><td align='left'>系统配置文件</td></tr>","<tr><td align='left'>/root</td><td align='left'>系统管理员的家目录</td></tr>","<tr><td align='left'>/home</td><td align='left'>用户家目录</td></tr>","<tr><td align='left'>/lib</td><td align='left'>开机时用到的函数库，以及/bin与/sbin下面的命令要调用的函数</td></tr>","<tr><td align='left'>/bin</td><td align='left'>存放单用户模式下还可以操作的命令，即Linux的基本命令</td></tr>","</tbody></table>","<h3 id='硬盘的命名与分区-0'>硬盘的命名与分区</h3>","<p>一般的硬盘设备都会是以<code>/dev/sd</code>开头的，一台主机上可以有多块硬盘，因此系统采用<code>a~p</code>来<strong>代表16块不同的硬盘</strong>，而且需要注意的是<strong>硬盘的分区编号</strong>：</p>","<ul>","<li>主分区或扩展分区的编号从1开始，到4结束</li>","<li>逻辑分区从编号5开始</li>","</ul>","<p>另外还需要注意的是：</p>","<ul>","<li>硬盘设备被分配到的名字，是<strong>由系统内核的识别顺序来决定</strong>的</li>","<li><strong>分区名称可以被手动指定</strong>，可能并不代表分区的顺序</li>","</ul>","<blockquote>","<p>关于<strong>扩展分区</strong>：</p>","<p>硬盘由大量扇区组成，每个扇区大小为<strong>512字节</strong>，第一个扇区保存着<strong>主引导记录</strong>与<strong>分区表</strong>的信息。</p>","<p>主引导记录<strong>446字节</strong>，分区表<strong>64字节</strong>，结束符<strong>2字节</strong>。</p>","<p>分区表中需要<strong>16字节</strong>来记录一个分区，因此最多记录4个分区。</p>","<p>我们通常使用<code>3主分区+1扩展分区</code>、<code>扩展分区划分为多个逻辑分区</code>的方式创建多个分区，这时，扩展分区就成为了<strong>指向其它分区的指针</strong>，为单向链表结构。</p>","</blockquote>","<h2 id='7.RAID与LVM-0'>7.RAID与LVM</h2>","<h3 id='7.1独立冗余磁盘阵列のRAID-0'>7.1独立冗余磁盘阵列のRAID</h3>","<p>RAID通过把多个硬盘设备组合成一个容量更大、安全性更好的磁盘阵列，并把数据分割成多个区段后分别存放在各个不同的物理硬盘设备上，同时使用了分散读写技术来提升硬盘阵列整体的性能。</p>","<ul>","<li>","<p><code>RAID 0</code>：提升硬盘设备的读写速度</p>","</li>","</ul>","<p>把多块物理硬盘设备通过硬件或软件的方式串联在一起，并将数据一次写入到各个物理硬盘中。</p>","<p>就像是把所有的联系人信息分别记录在两个电话本上。</p>","<p>RAID 0技术能够有效地<strong>提升硬盘数据的吞吐速度</strong>，但是<strong>不具备数据备份和错误修复能力</strong>，同时<strong>任意一块硬盘发生故障将导致整个系统数据损坏</strong>。</p>","<ul>","<li>","<p><code>RAID 1</code>：增加数据的安全性</p>","</li>","</ul>","<p>把两块以上的硬盘进行绑定，将一份数据同时写入到多块硬盘设备上。</p>","<p>就像是把所有的联系人信息，制作成多份一模一样的电话本。</p>","<p>当其中某一块硬盘发生故障后，一般会<strong>立即自动以热交换的方式来恢复数据</strong>的正常使用，缺点就是<strong>硬盘设备的利用率下降</strong>。</p>","<ul>","<li>","<p><code>RAID 5</code>：对读写速度、数据安全、成本的妥协</p>","</li>","</ul>","<p>与RAID 0一样，RAID 5的硬盘数据是无备份的，但是它把单块物理硬盘设备的数据奇偶校验信息保存在<strong>除自身以外的每一块</strong>物理硬盘上，当硬盘设备出现问题后<strong>通过奇偶校验信息来尝试重建损坏的数据</strong>。</p>","<ul>","<li>","<p><code>RAID 10</code>：RAID 0与RAID 1的组合</p>","</li>","</ul>","<p>该技术至少需要4块硬盘来组建，其中先分别两i昂制作成RAID 1磁盘阵列，以保证数据的安全性；然后再对两个RAID 1磁盘阵列实施RAID 0技术，进一步提高硬盘设备的读写速度。</p>","<p>在不考虑成本的情况下，RAID 10的<strong>各方面都超过了</strong>RAID 5。</p>","<h3 id='7.2逻辑卷管理器のLVM-0'>7.2逻辑卷管理器のLVM</h3>","<h2 id='8.操作-0'>8.操作</h2>","<h3 id='8.1判断用户输入的成绩-0'>8.1判断用户输入的成绩</h3>","<p><span id='grep_used'></span></p>","<p>编写一个Shell脚本，使得能够接收用户输入的成绩，判断用户的输入是否合法，并给出相应的提示。</p>","<pre>","<code>#!/b<span class='hl-keyword'>in</span>/bash</code>","<code>read -p \"请输入你的成绩，并按下ENTER：\" GRADE</code>","<code>grade=`echo \"$GRADE\" | grep '[0-9]\\{0,3\\}'`</code>","<code>minus=`echo \"$GRADE\" | grep '^-'`</code>","<code><span class='hl-keyword'>if</span> [ -z $grade ];then</code>","<code>echo \"你输入了数字以外的字符\"</code>","<code><span class='hl-keyword'>else</span> <span class='hl-keyword'>if</span> [ ! -z $grade ] && [ ! -z $minus ];then</code>","<code>echo \"你输入了负数\"</code>","<code>el<span class='hl-keyword'>if</span> [ $grade -ge 101 ];then</code>","<code>echo \"你的输入大于100\"</code>","<code>el<span class='hl-keyword'>if</span> [ $grade -ge 85 ] && [ $grade -le 100 ];then</code>","<code>echo \"你很棒\"</code>","<code>el<span class='hl-keyword'>if</span> [ $grade -ge 60 ] && [ $grade -le 84 ];then</code>","<code>echo \"你合格了\"</code>","<code>el<span class='hl-keyword'>if</span> [ $grade -le 59 ];then</code>","<code>echo \"你不合格\"</code>","<code>fi</code>","<code>fi</code>","</pre>","<p>值得注意的是<code>read</code>命令的使用、管道命令符<code>|</code>的使用、Linux中的正则表达式。</p>","<h3 id='8.2切换网卡信息-0'>8.2切换网卡信息</h3>","<p>编写一个Shell脚本，接收用户输入的参数，使之能够切换网络配置。</p>","<p>嗯，用Win用惯了的我居然想不到存在Linux不同版本的适配问题：我用的是<code>Ubuntu</code>，而教学用的是<code>Red Hat</code>。两个系统的文件结构存在一定的差异，当然<code>CentOS</code>自然也有不同。</p>","<p>Ubuntu下并没有<code>/etc/sysconfig/*</code>，对于下面的文件夹需要到各个服务的存放位置分别寻找，如本实例用到的<code>/etc/sysconfig/network</code>对应Ubuntu中的<code>/etc/network/interfaces</code>文件。而CentOS虽然存在着这个文件夹，但是文件名称由<code>ifcfg-eno16777736</code>变成了较早之前的<code>ifcfg-eth0</code>。</p>","<p>在下面的脚本中，我只考虑了Ubuntu和Ret Hat的差别，没有考虑CentOS。</p>","<pre>","<code>#!/b<span class='hl-keyword'>in</span>/bash</code>","<code>if_Ubuntu=`cat /etc/issue | grep 'Ubuntu'`;</code>","<code><span class='hl-keyword'>if</span> [ -z $if_Ubuntu ];then</code>","<code>#不是Ubuntu系统</code>","<code><span class='hl-keyword'>if</span> [ $1 = 'home' ];then</code>","<code>su<span class='hl-keyword'>do</span> cp ~/ifcfg-eno16777736_home /etc/sysconfig/network-scripts/ifcfg-eno16777736_home</code>","<code>el<span class='hl-keyword'>if</span> [ $1 = 'office' ];then</code>","<code>su<span class='hl-keyword'>do</span> cp ~/ifcfg-eno16777736_office /etc/sysconfig/network-scripts/ifcfg-eno16777736_office</code>","<code>fi</code>","<code><span class='hl-keyword'>else</span></code>","<code>#是Ubuntu系统</code>","<code><span class='hl-keyword'>if</span> [ $1 = 'home' ];then</code>","<code>su<span class='hl-keyword'>do</span> cp ~/interfaces_home /etc/network/interfaces</code>","<code>el<span class='hl-keyword'>if</span> [ $1 = 'office' ];then</code>","<code>su<span class='hl-keyword'>do</span> cp ~/interfaces_office /etc/network/interfaces</code>","<code>fi</code>","<code>fi</code>","<code>service network restart</code>","</pre>","<p>通过查看<code>/etc/issue</code>的输出内容查看当前Linux的系统类型，操作并替换网络配置信息。</p>","<p>当然，要是你是<code>Red Hat</code>而且嫌麻烦，你完全可以这么写：</p>","<pre>","<code>#!/b<span class='hl-keyword'>in</span>/bash</code>","<code><span class='hl-keyword'>if</span> [ $1 = 'home' ];then</code>","<code>su<span class='hl-keyword'>do</span> cp ~/ifcfg-eno16777736_home /etc/sysconfig/network-scripts/ifcfg-eno16777736_home</code>","<code>el<span class='hl-keyword'>if</span> [ $1 = 'office' ];then</code>","<code>su<span class='hl-keyword'>do</span> cp ~/ifcfg-eno16777736_office /etc/sysconfig/network-scripts/ifcfg-eno16777736_office</code>","<code>fi</code>","</pre>","<p>那么，这个<code>~/ifcfg-eno16777736_home</code>或者<code>~/interfaces_home</code>文件中应该放什么东西呢？</p>","<ul>","<li>","<p>对于<code>Ubuntu</code>系统，将动态分配的IP改成静态分配的IP</p>","</li>","</ul>","<pre>","<code>#XXX就是你网卡的名字，比如enp0s3</code>","<code>iface XXX inet <span class='hl-keyword'>static</span></code>","<code>address 192.168.0.100</code>","<code>netmask 255.255.255.0</code>","<code>gateway 192.168.0.254</code>","</pre>","<ul>","<li>","<p>对于<code>Ret Hat</code>系统，将动态分配的IP改成静态分配的IP</p>","</li>","</ul>","<pre>","<code>TYPE=Ethernet  #网络类型为以太网</code>","<code>HWADDR=XX:XX:xx:xx:xx  #MAC地址</code>","<code>UUID=xxxxxxxxxxxx  #网卡标识号</code>","<code>#主要修改下面这里，内容不是固定的，仅作为参考</code>","<code>BOOTPROTO=<span class='hl-object'>none</span>|dhcp|<span class='hl-keyword'>static</span>  #ip地址是否动态分配</code>","<code>ONBOOT=yes  #是否在开机/重启的时候启动网卡</code>","<code>NETMASK=255.255.255.0  #子网掩码</code>","<code>IPADDRD=192.168.10.10  #IPADDR即ip地址</code>","<code>GATEWAY=10.0.0.2  #网关</code>","</pre>","<p>当然，我们还可以通过使用<code>nmtui</code>命令，来直观的使用类GUI页面进行网络配置。</p>"]}]